<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="gamePageTitle">Вестерия: Загрузка...</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Loading overlay styles */
        body.loading-overlay::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            animation: fadeIn 0.3s ease-out;
        }
        body.loading-overlay .loader-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2001;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        body.loading-overlay .game-container {
            display: none; /* Hide game container when loading */
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        /* Custom scrollbar for scrollable areas */
        .scrollable-area::-webkit-scrollbar {
            width: 8px;
        }
        .scrollable-area::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .scrollable-area::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .scrollable-area::-webkit-scrollbar-thumb:hover {
            background: #555;
            cursor: pointer;
        }
        /* Font family */
        body {
            font-family: 'Inter', sans-serif;
        }
/* Динамический фон для игрового контейнера и страницы */
#gameContainer {
    transition: background-color 2s ease-in-out; /* Плавный переход цвета для контейнера */
}
body {
    transition: background-color 2s ease-in-out; /* Плавный переход цвета для страницы */
}
        /* Tooltip styles */
        .game-tooltip {
            position: fixed;
            background-color: #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            white-space: nowrap;
            transition: opacity 0.2s;
            opacity: 0;
            pointer-events: none; /* Allows clicks to pass through when not visible */
            max-width: 250px; /* Limit tooltip width for better readability */
            white-space: normal; /* Allow text to wrap */
        }
        .game-tooltip.visible {
            opacity: 1;
            pointer-events: all; /* Allow interaction when visible */
        }
        /* Progress bar styles */
        .progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            height: 10px;
        }
        .progress-bar {
            height: 100%;
            border-radius: 5px;
            text-align: right;
            transition: width 0.5s ease-in-out; /* Smooth transition for width changes */
        }
        .xp-bar { background-color: #facc15; } /* Tailwind yellow-400 */
        .hunger-bar { background-color: #eab308; } /* Tailwind amber-500 */
        .thirst-bar { background-color: #0ea5e9; } /* Tailwind sky-500 */
        .cleanliness-bar { background-color: #6d28d9; } /* Tailwind violet-700 */
        /* Equipment list item styles */
        .equipment-list-item {
            display: flex;
            align-items: center;
            padding: 2px 0;
            margin-bottom: 4px;
        }
        .equipment-list-item i {
            margin-right: 8px;
            font-size: 1rem;
            color: #4a4a4a; /* Dark gray for icons */
            width: 1.2em; /* Fixed width for consistent alignment */
            text-align: center;
        }
        .equipment-list-item span {
            font-size: 0.8rem;
            color: #333; /* Darker text */
        }
        .equipment-list-item .unequip-btn {
            margin-left: auto; /* Push button to the right */
            padding: 2px 6px;
            font-size: 0.7rem;
            background-color: #ef4444; /* Tailwind red-500 */
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .equipment-list-item .unequip-btn:hover {
            background-color: #dc2626; /* Tailwind red-600 */
        }
        /* Skill item animation for upgrade */
        .skill-item.upgraded {
            background-color: #d1fae5; /* Tailwind green-100 */
            animation: pulse 1s forwards; /* Apply pulse animation */
            border-radius: 5px;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); } /* Tailwind green-500 with opacity */
            70% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }
        /* Inventory item use button */
        .inventory-item .use-btn {
            margin-left: 8px;
            padding: 2px 6px;
            font-size: 0.7rem;
            background-color: #22c55e; /* Tailwind green-500 */
            color: white;
            border-radius: 44px; /* Pill shape */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .inventory-item .use-btn:hover {
            background-color: #16a34a; /* Tailwind green-600 */
        }
        /* Modal overlay and content */
        .modal {
            position: fixed;
            z-index: 3000; /* Above everything else */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6); /* Semi-transparent black overlay */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            width: 80%;
            max-width: 400px; /* Max width for modals */
            text-align: center;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
/* НОВЫЕ СТИЛИ: для журналов */
.journal-entry {
    background-color: #f8fafc; /* very light gray */
    border-left: 4px solid #6366f1; /* indigo-500 */
    padding: 12px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.journal-entry:hover {
    background-color: #eef2ff; /* indigo-50 */
}
.journal-entry h4 {
    font-family: 'Caveat', cursive; /* Рукописный шрифт для заголовков */
    font-weight: bold;
    font-size: 1.5rem;
    color: #4338ca; /* indigo-700 */
}
.journal-entry p, .journal-entry ul {
    font-family: 'Inter', sans-serif; /* Обычный шрифт для основного текста */
    font-size: 0.9rem;
    color: #374151; /* gray-700 */
    line-height: 1.5;
}
.journal-entry .meta {
    font-family: 'Inter', sans-serif; /* Обычный шрифт для мета-информации */
    font-size: 0.75rem;
    color: #6b7280; /* gray-500 */
    font-style: italic;
    margin-top: 8px;
}
.quest-tab-content.hidden {
    display: none;
}
        .tab-button.active {
            background-color: #818cf8; /* Indigo-400 */
            color: white;
        }
        .property-category {
            margin-bottom: 1rem;
        }
        .property-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border-bottom: 1px dashed #ccc;
        }
        .property-item:last-child {
            border-bottom: none;
        }
        .property-item i {
            margin-right: 0.5rem;
            color: #4a4a4a;
        }
        .property-item span {
            font-size: 0.9rem;
            color: #333;
        }
/* НОВОЕ: Стили для интерактивной карты */
#mapContainer:active {
    cursor: grabbing;
}

#mapCanvas .location-group .location-circle {
    transition: all 0.2s ease-in-out;
    stroke: #4a2c0d; /* Коричневая обводка */
    stroke-width: 2px;
}

#mapCanvas .location-group .location-label {
    font-family: 'Caveat', cursive;
    font-size: 16px;
    fill: #3d270c;
    paint-order: stroke;
    stroke: #f5deb3; /* Светлая обводка текста для читаемости */
    stroke-width: 3px;
    stroke-linecap: butt;
    stroke-linejoin: miter;
    font-weight: bold;
}

#mapCanvas .location-group:hover .location-circle {
    transform: scale(1.5);
    filter: drop-shadow(0 0 5px #fef08a); /* Желтое свечение при наведении */
}

#mapCanvas .location-group.current-location .location-circle {
    fill: #dc2626; /* Ярко-красный для текущей локации */
    stroke: #fef08a; /* Желтая обводка */
}

#mapCanvas .location-group.current-location .location-star {
    fill: #fef08a;
    font-size: 20px;
}

#mapCanvas .connection-line {
    stroke: #854d0e; /* Темно-коричневый для путей */
    stroke-width: 1.5px;
    stroke-dasharray: 4, 4;
}

#mapCanvas .connection-label {
    fill: #4a2c0d;
    font-size: 12px;
    font-family: 'Inter', sans-serif;
}
/* НОВОЕ: Стили для регионов на карте */
#mapCanvas .region-shape {
    fill: rgba(120, 82, 22, 0.15); /* Полупрозрачный коричневый */
    stroke: rgba(161, 98, 7, 0.4);
    stroke-width: 2px;
    stroke-dasharray: 10, 5;
}

#mapCanvas .region-label {
    fill: rgba(161, 98, 7, 0.7);
    font-size: 48px; /* Крупный текст для названия региона */
    font-family: 'Caveat', cursive;
    text-anchor: middle;
    font-weight: bold;
    pointer-events: none; /* Чтобы не мешал кликам */
}
#mapCanvas .location-group .details-group {
    display: none; /* По умолчанию все мелкие детали скрыты */
}

/* Показываем детали при определенном уровне зума */
#mapCanvas[data-zoom-level='2'] .zoom-level-2,
#mapCanvas[data-zoom-level='3'] .zoom-level-2,
#mapCanvas[data-zoom-level='3'] .zoom-level-3 {
    display: block;
}

/* Стили для разных типов локаций */
#mapCanvas .location-forest {
    fill: #166534; /* Темно-зеленый для леса */
}

#mapCanvas .location-city {
    fill: #f59e0b; /* Янтарный для города */
}

#mapCanvas .location-default {
    fill: #fcd34d; /* Стандартный желтый */
}
    </style>
</head>
<body class="flex items-center justify-center min-h-screen bg-gray-100 p-4 loading-overlay">
    <div id="globalLoader" class="loader-text">
        <i class="fas fa-spinner fa-spin"></i> Загрузка игры, пожалуйста, подождите...
    </div>
    <div id="gameContainer" class="game-container w-full max-w-6xl bg-white rounded-lg shadow-lg p-6 flex flex-col lg:flex-row gap-6">
        <div class="flex flex-col gap-4 w-full lg:w-1/4">
            <div class="bg-gray-50 rounded-md p-3 border border-gray-200">
    <h2 class="font-semibold text-gray-700 mb-2 text-lg">Окружение <i class="fas fa-eye text-gray-500"></i></h2>
    <div id="surroundingsOutput" class="scrollable-area h-40 overflow-y-auto text-xs leading-relaxed"></div>
</div>
        </div>
        <div class="flex flex-col gap-4 flex-grow w-full lg:w-2/4">
            <h1 id="gameTitle" class="text-3xl font-bold text-gray-800 text-center mb-2">Вестерия</h1>
            <div id="timeLocationDisplay" class="bg-blue-100 text-blue-800 text-sm rounded-md p-2 text-center font-medium border border-blue-200"></div>
            <div id="gameOutput" class="scrollable-area overflow-y-auto h-96 bg-gray-50 rounded-md p-3 text-sm leading-relaxed border border-gray-200"></div>
            <div id="dynamicOptions" class="flex flex-wrap gap-2 mt-2 justify-center"></div>
            <div class="flex gap-2 mt-4">
                <input type="text" id="commandInput" class="flex-grow p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Введите вашу команду..." disabled>
                <button id="submitCommand" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>Отправить</button>
            </div>
            <div id="loadingIndicator" class="text-center text-gray-500 text-sm hidden mt-2">
                <i class="fas fa-spinner fa-spin mr-2"></i> Венди обдумывает ваш ход...
             </div>
            
            <div id="combatInfo" class="bg-red-100 text-red-800 text-sm rounded-md p-2 mt-2 hidden border border-red-200">
                <h3 class="font-semibold text-base mb-1">Бой!</h3>
                <div id="enemyStatus" class="flex flex-wrap gap-x-4 gap-y-1 mb-2"></div>
                <div id="combatLog" class="scrollable-area h-24 overflow-y-auto mt-2 text-xs"></div>
            </div>
            <div id="thoughtsPanel" class="bg-yellow-100 text-yellow-800 text-sm rounded-md p-2 mt-2 hidden border border-yellow-200">
                <h3 class="font-semibold text-base mb-1" id="thoughtsPanelTitle">Твои мысли <i class="fas fa-brain text-yellow-600"></i></h3>
                <p id="characterCurrentThought" class="text-xs italic"></p>
            </div>
       
         
            <div id="gameOverMessage" class="bg-red-200 text-red-900 text-center p-4 rounded-md hidden mt-4">
                <h3 class="text-xl font-bold mb-2">Вы погибли...</h3>
                <p>Ваше приключение в этом теле окончено.</p>
            </div>
            
            <div class="flex flex-col gap-2 mt-4">
                <button id="newGameButton" class="px-4 py-2 bg-red-600 text-white text-sm font-semibold rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">Новая игра</button>
            </div>
        </div>
        <div class="flex flex-col gap-4 w-full lg:w-1/4">
            <div class="bg-gray-50 rounded-md p-3 border border-gray-200">
                <h2 class="font-semibold text-gray-700 mb-2 text-lg">Статус игрока <i class="fas fa-user-circle text-gray-500"></i></h2>
                <p class="text-xs">Здоровье: <span id="playerHealth" class="font-medium text-green-600"></span></p>
                <div class="progress-bar-container"><div id="healthBar" class="progress-bar bg-green-500"></div></div>
    
                <p class="text-xs mt-2">Выносливость: <span id="playerStamina" class="font-medium text-blue-600"></span></p>
                <div class="progress-bar-container"><div id="staminaBar" class="progress-bar bg-blue-500"></div></div>
                <p class="text-xs mt-2">Голод: <span id="playerHunger" class="font-medium text-yellow-600"></span></p>
                <div class="progress-bar-container"><div id="hungerBar" class="progress-bar hunger-bar"></div></div>
                <p class="text-xs mt-2">Жажда: <span id="playerThirst" class="font-medium text-sky-600"></span></p>
                <div class="progress-bar-container"><div id="thirstBar" class="progress-bar thirst-bar"></div></div>
                <p class="text-xs mt-2">Чистота: <span id="playerCleanliness" class="font-medium text-violet-600"></span></p>
                <div class="progress-bar-container"><div id="cleanlinessBar" class="progress-bar cleanliness-bar"></div></div>
                <p class="text-xs mt-2">Опыт: <span id="playerXP" class="font-medium text-yellow-600"></span></p>
              
                 <div class="progress-bar-container"><div id="xpBar" class="progress-bar xp-bar"></div></div>
                <p class="text-xs mt-2">Уровень: <span id="playerLevel" class="font-medium text-yellow-600"></span></p>
                <p class="text-xs mt-2">Очки навыков: <span id="skillPoints" class="font-medium text-purple-600"></span></p>
                <p class="text-xs mt-2">
                    Деньги: 
          
                     <span id="playerMoneyCopper" class="font-medium text-amber-700"></span>
                    <span id="playerMoneySilver" class="font-medium text-gray-500 ml-2"></span>
                    <span id="playerMoneyGold" class="font-medium text-yellow-500 ml-2"></span>
                </p>
                <p class="text-xs mt-2">Статусы: <span id="playerStatuses" class="font-medium text-purple-600"></span></p>
 
           </div>
            <div class="bg-gray-50 rounded-md p-3 border border-gray-200">
                <h2 class="font-semibold text-gray-700 mb-2 text-lg">Компаньоны <i class="fas fa-paw text-gray-500"></i></h2>
                <div id="companionsOutput" class="scrollable-area h-20 overflow-y-auto text-xs leading-relaxed"></div>
          
           </div>
            <div class="bg-gray-50 rounded-md p-3 border border-gray-200">
                <h2 class="font-semibold text-gray-700 mb-2 text-lg">Комфорт <i class="fas fa-thermometer-half text-gray-500"></i></h2>
                <div id="temperatureComfortContainer" class="w-full h-8 bg-gradient-to-r from-blue-500 via-green-500 to-red-500 rounded-md relative cursor-pointer" title="Нажмите для деталей">
           
                 <div id="comfortSlider" class="absolute top-0 w-3 h-full bg-white border border-gray-400 rounded-sm shadow-md transition-all duration-300 ease-in-out"></div>
                </div>
                <p id="currentComfortStatus" class="text-xs text-center mt-2 italic text-gray-600">Ощущается комфортно.</p>
            </div>
            <div class="bg-gray-50 rounded-md p-3 border border-gray-200">
          
               <h2 class="font-semibold text-gray-700 mb-2 text-lg">Экипировка <i class="fas fa-shield-alt text-gray-500"></i></h2>
                <ul id="playerEquipment" class="list-none text-xs">
                    <li class="equipment-list-item" data-slot="head">
                        <i class="fas fa-hat"></i> <span>Голова: <span id="eq_head"></span></span>
                
                         <button class="unequip-btn" data-slot="head">Снять</button>
                    </li>
                    <li class="equipment-list-item" data-slot="torso_clothing">
                        <i class="fas fa-tshirt"></i> <span>Одежда на торс: <span id="eq_torso_clothing"></span></span>
                 
                        <button class="unequip-btn" data-slot="torso_clothing">Снять</button>
                    </li>
                    <li class="equipment-list-item" data-slot="torso_armor">
                        <i class="fas fa-vest-patches"></i> <span>Броня на торс: <span id="eq_torso_armor"></span></span>
                  
                       <button class="unequip-btn" data-slot="torso_armor">Снять</button>
                    </li>
                    <li class="equipment-list-item" data-slot="legs_clothing">
                        <i class="fas fa-shoe-prints"></i> <span>Одежда на ноги: <span id="eq_legs_clothing"></span></span>
                   
                     <button class="unequip-btn" data-slot="legs_clothing">Снять</button>
                    </li>
                    <li class="equipment-list-item" data-slot="legs_armor">
                        <i class="fas fa-user-shield"></i> <span>Броня на ноги: <span id="eq_legs_armor"></span></span>
                    
                     <button class="unequip-btn" data-slot="legs_armor">Снять</button>
                    </li>
                    <li class="equipment-list-item" data-slot="feet">
                        <i class="fas fa-socks"></i> <span>Обувь: <span id="eq_feet"></span></span>
                       
                         <button class="unequip-btn" data-slot="feet">Снять</button>
                    </li>
                    <li class="equipment-list-item" data-slot="weapon">
                        <i class="fas fa-sword"></i> <span>Оружие: <span id="eq_weapon"></span></span>
                        <button class="unequip-btn" data-slot="weapon">Снять</button>
                    </li>
                    <li class="equipment-list-item" data-slot="shield">
                        <i class="fas fa-shield-alt"></i> <span>Щит: <span id="eq_shield"></span></span>
                        <button class="unequip-btn" data-slot="shield">Снять</button>
   
                     </li>
                    <li class="equipment-list-item" data-slot="amulet">
                        <i class="fas fa-gem"></i> <span>Амулет: <span id="eq_amulet"></span></span>
                        <button class="unequip-btn" data-slot="amulet">Снять</button>
      
                     </li>
                    <li class="equipment-list-item" data-slot="ring1">
                        <i class="fas fa-ring"></i> <span>Кольцо 1: <span id="eq_ring1"></span></span>
                        <button class="unequip-btn" data-slot="ring1">Снять</button>
        
                     </li>
                    <li class="equipment-list-item" data-slot="ring2">
                        <i class="fas fa-ring"></i> <span>Кольцо 2: <span id="eq_ring2"></span></span>
                        <button class="unequip-btn" data-slot="ring2">Снять</button>
          
                   </li>
                </ul>
            </div>
            <div class="bg-gray-50 rounded-md p-3 border border-gray-200">
                <h2 class="font-semibold text-gray-700 mb-2 text-lg">Инвентарь <i class="fas fa-briefcase text-gray-500"></i></h2>
                <ul id="playerInventory" class="list-disc list-inside text-xs"></ul>
 
                <h2 class="font-semibold text-gray-700 mt-2 mb-1 text-lg">Навыки <i class="fas fa-star text-gray-500"></i></h2>
                <ul id="playerSkills" class="list-disc list-inside text-xs"></ul>
                <div class="grid grid-cols-2 gap-2 mt-4">
    <button id="recordsButton" class="w-full px-4 py-2 bg-indigo-600 text-white font-semibold rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-sm">
        <i class="fas fa-scroll"></i> Записи
    </button>
    <button id="questsButton" class="w-full px-4 py-2 bg-amber-600 text-white font-semibold rounded-md hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-amber-500 text-sm">
        <i class="fas fa-tasks"></i> Квесты
    </button>
    <button id="charactersButton" class="w-full px-4 py-2 bg-sky-600 text-white font-semibold rounded-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 text-sm">
        <i class="fas fa-users"></i> Персонажи
    </button>
    <button id="locationsButton" class="w-full px-4 py-2 bg-emerald-600 text-white font-semibold rounded-md hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-emerald-500 text-sm">
        <i class="fas fa-landmark"></i> Локации
    </button>
</div>

<button id="mapButton" class="w-full mt-2 px-4 py-2 bg-amber-800 text-white font-semibold rounded-md hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-amber-500">
    <i class="fas fa-map-marked-alt"></i> Карта Мира
</button>
<button id="propertyButton" class="w-full mt-2 px-4 py-2 bg-teal-600 text-white font-semibold rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500">
    <i class="fas fa-home"></i> Имущество
</button>
            </div>       
            
            <div class="bg-gray-50 rounded-md p-3 border border-gray-200">
                <h2 class="font-semibold text-gray-700 mb-2 text-lg">Журнал Событий <i class="fas fa-clipboard-list text-gray-500"></i></h2>
                <div id="eventLogOutput" class="scrollable-area h-40 overflow-y-auto text-xs leading-relaxed"></div>
            </div>
        </div>
    </div>
    <div id="newGameModal" class="modal hidden">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4">Начать новую игру?</h3>
      
             <p>Ваш текущий прогресс будет потерян. Вы уверены?</p>
            <div class="modal-buttons">
                <button id="confirmNewGame" class="px-6 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700">Да, начать новую</button>
                <button id="cancelNewGame" class="px-6 py-2 bg-gray-300 text-gray-800 font-semibold rounded-md hover:bg-gray-400">Отмена</button>
            </div>
        </div>
    </div>
    <div id="charCreationModal" class="modal hidden">
    <div class="modal-content">
        <h3 class="text-xl font-bold mb-4">Создайте своего персонажа</h3>
        <div class="text-left mb-4">
            <label for="charNameInput" class="block text-sm font-medium text-gray-700">Имя:</label>
            <input type="text" id="charNameInput" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Введите имя вашего персонажа">
        </div>
        <div class="text-left mb-4">
            <label for="charGenderSelect" class="block text-sm font-medium text-gray-700">Пол:</label>
            <select id="charGenderSelect" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <option value="мужской">Мужской</option>
                <option value="женский">Женский</option>
            </select>
        </div>
        <div class="text-left mb-4">
            <label for="charRaceSelect" class="block text-sm font-medium text-gray-700">Раса:</label>
            <select id="charRaceSelect" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <option value="человек">Человек</option>
                <option value="эльф">Эльф</option>
                <option value="дварф">Дварф</option>
                <option value="орк">Орк</option>
                <option value="ведьмак">Ведьмак</option>
                <option value="тифлинг">Тифлинг</option>
                <option value="гном">Гном</option>
                <option value="полурослик">Полурослик</option>
                <option value="драконид">Драконид</option>
                <option value="фея">Фея</option>
            </select>
        </div>
        <div id="charDescription" class="text-xs text-gray-600 italic mb-4"></div>
        <div id="skillSelection" class="mb-4">
            <p class="text-sm font-medium text-gray-700 mb-2">Выберите стартовый навык:</p>
            <div id="skillOptions" class="flex flex-col gap-2">
            </div>
        </div>
        <div class="modal-buttons">
            <button id="createCharButton" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>Создать персонажа</button>
        </div>
    </div>
</div>
    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <h3 id="messageModalTitle" class="text-xl font-bold mb-4"></h3>
            <p id="messageModalContent"></p>
            <div class="modal-buttons">
                <button id="messageModalConfirmBtn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">OK</button>
            </div>
        </div>
    </div>
    <div id="recordsModal" class="modal hidden">
    <div class="modal-content !max-w-2xl !w-11/12 !p-6">
        <h3 class="text-2xl font-bold mb-4">Журнал Записей <i class="fas fa-scroll text-indigo-500"></i></h3>
        <div id="recordsContent" class="scrollable-area h-96 overflow-y-auto pr-2 text-left space-y-4">
            </div>
        <div class="modal-buttons">
            <button id="closeRecordsBtn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Закрыть</button>
        </div>
    </div>
</div>

<div id="questsModal" class="modal hidden">
    <div class="modal-content !max-w-2xl !w-11/12 !p-6">
        <h3 class="text-2xl font-bold mb-4">Список Заданий <i class="fas fa-tasks text-amber-500"></i></h3>
        <div class="flex border-b border-gray-300 mb-4">
            <button data-tab="personal" class="tab-button flex-1 py-2 text-sm font-medium text-center text-gray-600 hover:text-gray-800 focus:outline-none active rounded-t-lg">Личные</button>
            <button data-tab="global" class="tab-button flex-1 py-2 text-sm font-medium text-center text-gray-600 hover:text-gray-800 focus:outline-none rounded-t-lg">Глобальные</button>
            <button data-tab="completed" class="tab-button flex-1 py-2 text-sm font-medium text-center text-gray-600 hover:text-gray-800 focus:outline-none rounded-t-lg">Завершенные</button>
        </div>
        <div id="questsContent" class="scrollable-area h-96 overflow-y-auto pr-2 text-left">
            <div id="personalQuestsTab" class="quest-tab-content space-y-4"></div>
            <div id="globalQuestsTab" class="quest-tab-content hidden space-y-4"></div>
            <div id="completedQuestsTab" class="quest-tab-content hidden space-y-4"></div>
        </div>
        <div class="modal-buttons">
            <button id="closeQuestsBtn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Закрыть</button>
        </div>
    </div>
</div>

<div id="charactersModal" class="modal hidden">
    <div class="modal-content !max-w-2xl !w-11/12 !p-6">
        <h3 class="text-2xl font-bold mb-4">Известные Персонажи <i class="fas fa-users text-sky-500"></i></h3>
        <div id="charactersContent" class="scrollable-area h-96 overflow-y-auto pr-2 text-left space-y-4">
            </div>
        <div class="modal-buttons">
            <button id="closeCharactersBtn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Закрыть</button>
        </div>
    </div>
</div>

<div id="locationsModal" class="modal hidden">
    <div class="modal-content !max-w-2xl !w-11/12 !p-6">
        <h3 class="text-2xl font-bold mb-4">Известные Локации <i class="fas fa-landmark text-emerald-500"></i></h3>
        <div id="locationsContent" class="scrollable-area h-96 overflow-y-auto pr-2 text-left space-y-4">
            </div>
        <div class="modal-buttons">
            <button id="closeLocationsBtn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Закрыть</button>
        </div>
    </div>
</div>
    <div id="characterDescriptionModal" class="modal hidden">
        <div class="modal-content !max-w-md !w-11/12 !p-6">
            <h3 class="text-2xl font-bold mb-4">О персонаже <i class="fas fa-user-edit"></i></h3>
            <div id="characterDescriptionContent" class="text-left scrollable-area h-auto max-h-80 overflow-y-auto pr-2">
                </div>
            <div class="modal-buttons">
                <button id="closeCharDescriptionBtn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Закрыть</button>
            </div>
        </div>
    </div>
    <div id="propertyModal" class="modal hidden">
        <div class="modal-content !max-w-xl !w-11/12 !p-6">
            <h3 class="text-2xl font-bold mb-4">Мое Имущество <i class="fas fa-building"></i></h3>
            <div id="propertyContent" class="scrollable-area h-80 overflow-y-auto pr-2 text-left">
                <div id="ownedHouses" class="property-category">
                    <h4 class="font-semibold text-lg text-gray-700 mb-2">Дома <i class="fas fa-house-user"></i></h4>
               
                     <ul class="list-none" id="housesList"></ul>
                </div>
                <div id="ownedPlots" class="property-category">
                    <h4 class="font-semibold text-lg text-gray-700 mb-2">Участки <i class="fas fa-tree"></i></h4>
                    <ul class="list-none" id="plotsList"></ul>
          
               </div>
                <div id="ownedFields" class="property-category">
                    <h4 class="font-semibold text-lg text-gray-700 mb-2">Поля <i class="fas fa-seedling"></i></h4>
                    <ul class="list-none" id="fieldsList"></ul>
                </div>
           
                 <div id="ownedBarns" class="property-category">
                    <h4 class="font-semibold text-lg text-gray-700 mb-2">Сараи <i class="fas fa-warehouse"></i></h4>
                    <ul class="list-none" id="barnsList"></ul>
                </div>
                <div id="ownedLivestock" class="property-category">
          
                     <h4 class="font-semibold text-lg text-gray-700 mb-2">Скот <i class="fas fa-cow"></i></h4>
                    <ul class="list-none" id="livestockList"></ul>
                </div>
                <div id="ownedVehicles" class="property-category">
                    <h4 class="font-semibold text-lg text-gray-700 mb-2">Повозки <i class="fas fa-truck-moving"></i></h4>
                    <ul class="list-none" id="vehiclesList"></ul>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="closePropertyBtn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Закрыть</button>
            </div>
 
           </div>
    </div>
<div id="mapModal" class="modal hidden">
    <div class="modal-content !max-w-6xl !w-11/12 !p-2 bg-stone-800 border-4 border-amber-800" style="box-shadow: 0 0 20px rgba(0,0,0,0.7), inset 0 0 15px rgba(0,0,0,0.5);">
        <div id="mapHeader" class="flex justify-between items-center p-2 border-b-2 border-amber-800">
            <h3 class="text-2xl font-bold text-amber-100" style="font-family: 'Caveat', cursive;">Карта Вестерии</h3>
            <div id="mapControls" class="flex items-center gap-3">
                 <button id="zoomInBtn" class="px-3 py-1 bg-amber-700 text-white font-bold rounded-full hover:bg-amber-600 text-lg">+</button>
                 <button id="zoomOutBtn" class="px-3 py-1 bg-amber-700 text-white font-bold rounded-full hover:bg-amber-600 text-lg">-</button>
                 <button id="resetViewBtn" class="px-3 py-1 bg-amber-700 text-white font-bold rounded-full hover:bg-amber-600"><i class="fas fa-crosshairs"></i></button>
            </div>
            <button id="closeMapBtn" class="text-amber-100 hover:text-white text-2xl font-bold">&times;</button>
        </div>
        <div id="mapContainer" class="w-full h-[75vh] relative overflow-hidden cursor-grab bg-yellow-50/10" style="background-image: url('data:image/svg+xml;utf8,<svg width=\"100\" height=\"100\"-xmlns=\"http://www.w3.org/2000/svg\"><defs><pattern id=\"old-paper\" patternUnits=\"userSpaceOnUse\" width=\"100\" height=\"100\"><image-href=\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAA8ADwDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECA//EABwQAQEBAAEFAAAAAAAAAAAAAAABEQISsfBBUf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/EABYRAQEBAAAAAAAAAAAAAAAAAAARAf/aAAwDAQACEQMRAD8A9xFAAAAAAAzcaaAAAAAAMm+bUAAAABG49NQAAAAEZ201AAAAARuPTUAAAABGdtNQAAAAEb201AAAAAQu2mgAAAACH//Z\" x=\"0\" y=\"0\" width=\"100\" height=\"100\" /></pattern></defs><rect width=\"100%\" height=\"100%\" fill=\"url(%23old-paper)\" /></svg>'); background-color: #f5deb3;">
            <svg id="mapCanvas" width="100%" height="100%"></svg>
<div id="mapTooltip" class="absolute hidden bg-stone-900/80 backdrop-blur-sm border-2 border-amber-500 rounded-lg shadow-xl p-4 text-amber-50 max-w-xs pointer-events-none">
    <h4 id="tooltipTitle" class="text-lg font-bold text-amber-300 mb-2"></h4>
    <p id="tooltipDescription" class="text-sm mb-3"></p>
    <div id="tooltipPlaces">
        <h5 class="font-semibold border-t border-amber-700 pt-2">Известные места:</h5>
        <ul id="tooltipPlacesList" class="list-disc list-inside text-sm mt-1">
            </ul>
    </div>
</div>
            <div id="mapCompass" class="absolute top-4 left-4 w-20 h-20 bg-gray-800/50 border-2 border-amber-600 rounded-full flex items-center justify-center text-white font-bold">
                <div class="absolute top-0 w-full text-center">С</div>
                <div class="absolute bottom-0 w-full text-center">Ю</div>
                <div class="absolute left-0 h-full flex items-center pl-2">З</div>
                <div class="absolute right-0 h-full flex items-center pr-2">В</div>
            </div>
        </div>
    </div>
</div>
    <script type="module">
        // Firebase imports MUST be at the very top of the module script
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // Global variables for Firebase and app ID
        let app;
        let db;
        let auth;
        let userId;
        // __app_id is provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let isGameReady = false;
        let characterCreationInProgress = false;
// Список стоп-слов для фильтрации ключевых слов
const russianStopWords = [
  'и', 'в', 'во', 'не', 'что', 'он', 'на', 'я', 'с', 'со', 'как', 'а', 'то', 'все', 'она', 'так', 'его', 'но', 'да', 'ты',
  'к', 'у', 'же', 'вы', 'за', 'бы', 'по', 'только', 'ее', 'мне', 'было', 'вот', 'от', 'меня', 'еще', 'нет', 'о', 'из', 'ему',
  'теперь', 'когда', 'даже', 'ну', 'вдруг', 'ли', 'если', 'уже', 'или', 'ни', 'быть', 'был', 'него', 'до', 'вас', 'нибудь',
  'опять', 'уж', 'вам', 'ведь', 'там', 'потом', 'себя', 'ничего', 'ей', 'может', 'они', 'тут', 'где', 'есть', 'надо',
  'ней', 'для', 'мы', 'тебя', 'их', 'чем', 'была', 'сам', 'чтоб', 'без', 'будто', 'чего', 'раз', 'тоже', 'себе', 'под',
  'будет', 'ж', 'тогда', 'кто', 'этот', 'того', 'потому', 'этого', 'какой', 'совсем', 'ним', 'здесь', 'этом', 'один',
  'почти', 'мой', 'тем', 'чтобы', 'нее', 'сейчас', 'были', 'куда', 'зачем', 'всех', 'никогда', 'можно', 'при', 'наконец',
  'два', 'об', 'другой', 'хоть', 'после', 'над', 'больше', 'тот', 'через', 'эти', 'нас', 'про', 'всего', 'них', 'какая',
  'много', 'разве', 'три', 'эту', 'моя', 'впрочем', 'хорошо', 'свою', 'этой', 'перед', 'иногда', 'лучше', 'чуть', 'том',
  'нельзя', 'такой', 'им', 'более', 'всегда', 'конечно', 'всю', 'между', 'осмотреть', 'посмотреть', 'осмотреться',
  'послушать', 'понюхать', 'идти', 'дальше'
];
// НОВАЯ ФУНКЦИЯ: Обновляет список 5 последних ключевых слов с приоритетом
/**
 * Обновляет `gameState.narrative.recentKeywords`.
 * @param {string} userCommand - Команда игрока.
 * @param {string} llmNarrative - Текст ответа нейросети.
 * @param {Array<string>} [priorityKeywords=[]] - Массив приоритетных слов (имен, названий) от LLM.
 */
function updateRecentKeywords(userCommand, llmNarrative, priorityKeywords = []) {
  const MAX_KEYWORDS = 5; // Храним 5 последних ключевых слов

  // 1. Собираем обычные (неприоритетные) слова
  const context = (
    userCommand + ' ' +
    (llmNarrative || '')
  ).toLowerCase(); // БЕЗ slavaThoughts

  const generalKeywords = context.split(/[\s,.;:!?]+/)
    .filter(word => word.length > 2 && !russianStopWords.includes(word));
  
  // 2. Нормализуем приоритетные слова (в нижний регистр)
  const normalizedPriorityKeywords = priorityKeywords.map(k => k.toLowerCase());

  // 3. Собираем все слова (приоритетные идут в конец, чтобы быть "самыми свежими")
  const allNewKeywords = [...generalKeywords, ...normalizedPriorityKeywords];
  
  if (allNewKeywords.length === 0) return; // Нет новых слов

  // 4. Получаем текущий список
  let recentKeywords = gameState.narrative.recentKeywords || [];

  // 5. Добавляем новые слова, обеспечивая уникальность и свежесть
  for (const keyword of allNewKeywords) {
    // Удаляем, если слово уже было (чтобы оно переместилось в конец)
    const index = recentKeywords.indexOf(keyword);
    if (index > -1) {
      recentKeywords.splice(index, 1);
    }
    // Добавляем в конец (самое свежее)
    recentKeywords.push(keyword);
  }
  
  // 6. Оставляем только 5 последних
  if (recentKeywords.length > MAX_KEYWORDS) {
    recentKeywords = recentKeywords.slice(-MAX_KEYWORDS);
  }

  gameState.narrative.recentKeywords = recentKeywords;
  console.log('[updateRecentKeywords] Обновленный список ключевых слов (приоритет в конце):', recentKeywords);
}
// НОВАЯ УМНАЯ ФУНКЦИЯ: Собирает релевантные и хронологические элементы
/**
 * Собирает релевантные элементы из массива на основе ключевых слов, а также последние N элементов.
 * @param {Array} fullArray - Полный массив для поиска (e.g., gameState.world.npcs).
 * @param {Array<string>} keywords - Массив очищенных ключевых слов для поиска.
 * @param {Array<string>} propertiesToSearch - Массив названий полей, в которых искать (e.g., ['name', 'description']).
 * @param {string} keyField - Поле для уникальной идентификации (e.g., 'id', 'place').
 * @param {number} chronologicalCount - Сколько последних элементов всегда включать.
 * @param {boolean} includeChronological - Включать ли хронологические элементы (по умолчанию true).
 * @param {number} maxRelevant - Максимальное количество релевантных элементов для добавления.
 * @returns {Array} - Массив уникальных релевантных и хронологических элементов.
 */
function getRelevantItems(fullArray, keywords, propertiesToSearch, keyField, chronologicalCount, includeChronological = true, maxRelevant = 10) {
  if (!fullArray || fullArray.length === 0) return [];
  
  // Если нет ключевых слов, просто возвращаем хронологический срез
  if (keywords.length === 0 && includeChronological) {
    return fullArray.slice(-chronologicalCount);
  }
  if (keywords.length === 0 && !includeChronological) {
    return [];
  }

  const chronologicalItems = includeChronological ? fullArray.slice(-chronologicalCount) : [];
  const relevantItems = [];

  const chronologicalKeys = new Set(chronologicalItems.map(item => item[keyField]));

  // Проходим с КОНЦА массива, чтобы найти НАИБОЛЕЕ СВЕЖИЕ совпадения
  for (let i = fullArray.length - 1; i >= 0; i--) {
    const item = fullArray[i];
    const itemKey = item[keyField];

    // Если этот элемент уже есть в "хронологическом" списке, пропускаем его
    if (chronologicalKeys.has(itemKey)) {
      continue;
    }

    let searchText = '';
    for (const prop of propertiesToSearch) {
      if (item[prop] && typeof item[prop] === 'string') {
        // Ищем по нижнему регистру
        searchText += item[prop].toLowerCase() + ' ';
      }
    }

    // Ищем, содержит ли текст элемента ЛЮБОЕ из ключевых слов
    // Ключевые слова уже должны быть в нижнем регистре
    if (keywords.some(k => searchText.includes(k))) {
      relevantItems.push(item);
      // Мы нашли достаточно релевантных, выходим
      if (relevantItems.length >= maxRelevant) {
        break;
      }
    }
  }

  // Сначала идут хронологические, потом релевантные (хотя Map все равно сделает их уникальными)
  const combinedItems = [...chronologicalItems, ...relevantItems.reverse()]; // reverse, т.к. мы искали с конца

  // Удаляем дубликаты
  const uniqueMap = new Map(combinedItems.map(item => [item[keyField], item]));
  
  return [...uniqueMap.values()];
}
// НОВАЯ ФУНКЦИЯ: Обновляет список 10 последних ключевых слов ДИАЛОГА
/**
 * Обновляет `gameState.narrative.dialogueKeywords`.
 * @param {string} userCommand - Команда игрока.
 * @param {string} llmNarrative - Текст ответа нейросети (только 'text').
 * @param {Array<string>} [priorityKeywords=[]] - Массив приоритетных слов (имен, названий) от LLM.
 */
function updateDialogueKeywords(userCommand, llmNarrative, priorityKeywords = []) {
    const MAX_DIALOGUE_KEYWORDS = 10; // Храним 10 последних ключевых слов диалога
    
    // 1. Собираем слова ТОЛЬКО из диалога
    const context = (
        userCommand + ' ' +
        (llmNarrative || '')
    ).toLowerCase(); 
    
    const dialogueGeneralKeywords = context.split(/[\s,.;:!?]+/)
        .filter(word => word.length > 2 && !russianStopWords.includes(word));

    // 2. Нормализуем приоритетные слова (в нижний регистр)
    const normalizedPriorityKeywords = priorityKeywords.map(k => k.toLowerCase());
    
    // 3. Собираем все слова (приоритетные идут в конец, чтобы быть "самыми свежими")
    const allNewKeywords = [...dialogueGeneralKeywords, ...normalizedPriorityKeywords];

    if (allNewKeywords.length === 0) return; // Нет новых слов

    // 4. Получаем текущий список
    let dialogueKeywords = gameState.narrative.dialogueKeywords || [];

    // 5. Добавляем новые слова, обеспечивая уникальность и свежесть
    for (const keyword of allNewKeywords) {
        // Удаляем, если слово уже было (чтобы оно переместилось в конец)
        const index = dialogueKeywords.indexOf(keyword);
        if (index > -1) {
            dialogueKeywords.splice(index, 1);
        }
        // Добавляем в конец (самое свежее)
        dialogueKeywords.push(keyword);
    }

    // 6. Оставляем только 10 последних
    if (dialogueKeywords.length > MAX_DIALOGUE_KEYWORDS) {
        dialogueKeywords = dialogueKeywords.slice(-MAX_DIALOGUE_KEYWORDS);
    }
    
    gameState.narrative.dialogueKeywords = dialogueKeywords;
    console.log('[updateDialogueKeywords] Обновленный список (10) ДИАЛОГОВЫХ слов:', dialogueKeywords);
}
const MAP_WIDTH = 2000; // Ширина вашей виртуальной карты в пикселях
const MAP_HEIGHT = 1500; // Высота вашей виртуальной карты в пикселях
        
        // Default game state template
const defaultGameStateTemplate = {
    gameTitle: 'Вестерия',
    player: {
        name: 'Персонаж',
        gender: 'Неопределённый',
        race: 'человек', // НОВОЕ: Поле для расы
        citizenship: 'Нет гражданства',
        age: 21,
        characterDescription: 'Описание персонажа пока недоступно.',
        goals: {
            shortTerm: 'не определена',
            longTerm: 'не определена'
        },
        playerProfile: {
            playStyleTags: [],
            dominantTone: "нейтральный",
            interestLevel: "анализ..."
        },
        health: 100,
        stamina: 100,
        hunger: 0,
        thirst: 0,
        cleanliness: 100,
        money: { copper: 0, silver: 0, gold: 0 },
        xp: 0,
        level: 1,
        skillPoints: 0,
        equippedItems: { head: null, torso_clothing: null, torso_armor: null, legs_clothing: null, legs_armor: null, feet: null, weapon: null, shield: null, amulet: null, ring1: null, ring2: null },
        inventory: [],
        skills: [],
        companions: [],
        statuses: [],
        temporaryWarmth: 0,
        comfortInfo: { effectiveTemperature: 15, statusName: 'Ощущается комфортно.', description: 'Температурные данные недоступны.', appliedStatuses: [] },
        isSleeping: false,
        quests: {
            personal: [],
            global: [],
            completed: []
        },
        property: { houses: [], plots: [], fields: [], barns: [], livestock: [], vehicles: [] }
    },
    world: {
        currentLocation: { id: 'loc_unknown', name: 'Неизвестно', street: '', city: '', district: '', worldPart: '', indoors: false, warmSource: false },
        currentDate: 'Неизвестно',
        currentTime: 'Неизвестно',
        season: 'весна',
        globalPlot: {
            active: false,
            title: "Мирное время",
            description: "В мире пока спокойно.",
            currentStage: 0,
            maxStages: 15,
            nextEventTurn: 30,
            activeFactions: [],
            playerAwareness: 0
        },
        worldState: {
            economy: "стабильная",
            globalTension: 0,
            activeConflicts: [],
            rulingFaction: "Неизвестно"
        },
        turnCounter: 0,
        inCombat: false,
        combat: { enemies: [], turn: 'player', log: [] },
        weather: { type: 'Неизвестно', description: 'Погода еще не определена.', icon: 'fa-solid fa-question-circle', temperature: 'N/A' },
        indoorTemperature: 'N/A',
        npcs: [],
        knownLocations: [],
        visibleLore: [],
        characterEventLog: [],
        _globalLore: {
            map: { locations: {}, connections: {} },
            regions: {},
            globalEvents: [],
            // НОВОЕ: Матрица отношений рас и история
            raceRelations: {}, 
            raceHistory: []
        }
    },
    narrative: {
        history: [],
        eventLog: [],
        majorEvents: [],
        currentScene: { id: 'initial_load', text: `Добро пожаловать в Вестерию. Приготовьтесь к новому приключению!`, options: [] },
        slavaThoughts: 'Что происходит? Где я?',
        sceneDescription: 'Описание окружения пока недоступно.',
        interTurnLog: [],
        recentKeywords: [],
        dialogueKeywords: [],
        moneyLog: []
    },
    gamePhase: 'initial_setup'
};
        let gameState = {}; // Current mutable game state
        
        // Helper function to get XP needed for the next level (Algebraic Progression)
        function getXpForNextLevel(level) {
            if (level === 1) return 100;
            // Algebraic progression: 100, 150, 250, 400, 600...
            // Difference increases by 50 each level: +50, +100, +150, +200...
            // Formula: xp_needed(n) = 100 + sum_{i=1}^{n-1} (50 * i)
            // Sum of arithmetic series: sum_{i=1}^{k} i = k * (k + 1) / 2
            return 100 + 50 * (level - 1) * level / 2;
        }
        
        // Deep merge utility for loading game state
        function deepMerge(target, source) {
            for (const key in source) {
                // Ensure the key belongs to the source object directly
                if (source.hasOwnProperty(key)) {
                    // Check if both properties are objects and not arrays
                    if (source[key] instanceof Object && !Array.isArray(source[key]) &&
                        target.hasOwnProperty(key) && target[key] instanceof Object && !Array.isArray(target[key])) {
                        // Recursively merge objects
                        target[key] = deepMerge(target[key], source[key]);
                    } else {
                        // Overwrite target property with source property
                        target[key] = source[key];
                    }
                }
            }
            return target;
        }
// НОВАЯ ФУНКЦИЯ: Фильтрация памяти NPC на основе ролей (Участник/Свидетель)
/**
 * Выбирает из общего лога только те события, которые знает конкретный NPC.
 * Применяет логику 5 последних + 5 релевантных по ключевым словам.
 */
function getNpcMemories(npcId, fullLog, currentKeywords) {
    if (!fullLog || !Array.isArray(fullLog) || fullLog.length === 0) {
        return { relevantMemories: [] };
    }

    // 1. Фильтрация: NPC должен быть либо УЧАСТНИКОМ, либо СВИДЕТЕЛЕМ
    const knownEntries = fullLog.filter(entry => {
        const isParticipant = entry.participants && entry.participants.includes(npcId);
        const isWitness = entry.witnesses && entry.witnesses.includes(npcId);
        return isParticipant || isWitness;
    });

    // Если NPC ничего не помнит, возвращаем пустоту
    if (knownEntries.length === 0) return { relevantMemories: [] };

    // 2. Разделение на "Диалоги" и "События" (чтобы балансировать контекст)
    const dialogues = knownEntries.filter(e => e.type === 'dialogue');
    const events = knownEntries.filter(e => e.type === 'event');

    // Вспомогательная функция для выборки 5 последних + 5 по теме
    const selectMemories = (sourceArray) => {
        // А. Берем 5 самых последних хронологически (они в конце массива)
        const recent = sourceArray.slice(-5);
        
        // Б. Ищем 5 релевантных по ключевым словам (исключая те, что уже в recent)
        let relevant = [];
        if (currentKeywords && currentKeywords.length > 0) {
            const recentIds = new Set(recent.map(r => r.id));
            // Ищем с конца (от новых к старым)
            for (let i = sourceArray.length - 1; i >= 0; i--) {
                const entry = sourceArray[i];
                if (recentIds.has(entry.id)) continue; // Уже взяли

                // Проверка совпадения слов в тексте или тегах
                const hasKeyword = currentKeywords.some(kw => 
                    (entry.text && entry.text.toLowerCase().includes(kw)) ||
                    (entry.keywords && entry.keywords.includes(kw))
                );

                if (hasKeyword) {
                    relevant.push(entry);
                    if (relevant.length >= 5) break; // Хватит 5 штук
                }
            }
        }
        
        // Возвращаем объединенный массив
        return [...relevant.reverse(), ...recent];
    };

    const selectedDialogues = selectMemories(dialogues);
    const selectedEvents = selectMemories(events);

    // Объединяем и сортируем по времени (turn), чтобы ИИ читал историю последовательно
    const finalMemories = [...selectedEvents, ...selectedDialogues].sort((a, b) => a.turn - b.turn);

    // Удаляем дубликаты (на всякий случай)
    const uniqueMemories = [...new Map(finalMemories.map(item => [item.id, item])).values()];

    return { relevantMemories: uniqueMemories };
}
        
        // DOM element references
const gamePageTitle = document.getElementById('gamePageTitle');
const gameTitleEl = document.getElementById('gameTitle');
const gameOutput = document.getElementById('gameOutput');
const commandInput = document.getElementById('commandInput');
const submitCommandBtn = document.getElementById('submitCommand');
const playerHealthEl = document.getElementById('playerHealth');
const playerStaminaEl = document.getElementById('playerStamina');
const playerHungerEl = document.getElementById('playerHunger');
const playerThirstEl = document.getElementById('playerThirst');
const playerCleanlinessEl = document.getElementById('playerCleanliness');
const playerMoneyCopperEl = document.getElementById('playerMoneyCopper');
const playerMoneySilverEl = document.getElementById('playerMoneySilver');
const playerMoneyGoldEl = document.getElementById('playerMoneyGold');
const playerStatusesEl = document.getElementById('playerStatuses');
const playerInventoryEl = document.getElementById('playerInventory');
const playerSkillsEl = document.getElementById('playerSkills');
const loreOutput = document.getElementById('loreOutput');
// --- ИЗМЕНЕНИЕ ---
// Мы удалили const npcOutput = document.getElementById('npcOutput');
// и добавили const surroundingsOutput
const surroundingsOutput = document.getElementById('surroundingsOutput');
// --- КОНЕЦ ИЗМЕНЕНИЯ ---
const eventLogOutput = document.getElementById('eventLogOutput');
const timeLocationDisplay = document.getElementById('timeLocationDisplay');
const dynamicOptionsDiv = document.getElementById('dynamicOptions');
const combatInfoDiv = document.getElementById('combatInfo');
const enemyStatusEl = document.getElementById('enemyStatus');
const combatLogEl = document.getElementById('combatLog');
const healthBarEl = document.getElementById('healthBar');
const staminaBarEl = document.getElementById('staminaBar');
const hungerBarEl = document.getElementById('hungerBar');
const thirstBarEl = document.getElementById('thirstBar');
const cleanlinessBarEl = document.getElementById('cleanlinessBar');
const xpBarEl = document.getElementById('xpBar');
const playerXP_El = document.getElementById('playerXP');
const playerLevel_El = document.getElementById('playerLevel');
const skillPointsEl = document.getElementById('skillPoints');
const loadingIndicatorEl = document.getElementById('loadingIndicator');
const globalLoaderEl = document.getElementById('globalLoader');
const gameContainerEl = document.getElementById('gameContainer');
const thoughtsPanel = document.getElementById('thoughtsPanel');
const thoughtsPanelTitle = document.getElementById('thoughtsPanelTitle');
const characterCurrentThought = document.getElementById('characterCurrentThought');
const playerEquipmentEl = document.getElementById('playerEquipment');
const newGameButton = document.getElementById('newGameButton');
const newGameModal = document.getElementById('newGameModal');
const confirmNewGameBtn = document.getElementById('confirmNewGame');
const cancelNewGameBtn = document.getElementById('cancelNewGame');
const gameOverMessage = document.getElementById('gameOverMessage');
const charCreationModal = document.getElementById('charCreationModal');
const charNameInput = document.getElementById('charNameInput');
const charGenderSelect = document.getElementById('charGenderSelect');
const charRaceSelect = document.getElementById('charRaceSelect');
const charDescription = document.getElementById('charDescription');
const skillSelection = document.getElementById('skillSelection');
const skillOptionsDiv = document.getElementById('skillOptions');
const createCharButton = document.getElementById('createCharButton');
const messageModal = document.getElementById('messageModal');
const messageModalTitle = document.getElementById('messageModalTitle');
const messageModalContent = document.getElementById('messageModalContent');
const messageModalConfirmBtn = document.getElementById('messageModalConfirmBtn');
const temperatureComfortContainer = document.getElementById('temperatureComfortContainer');
const comfortSlider = document.getElementById('comfortSlider');
const currentComfortStatus = document.getElementById('currentComfortStatus');
const companionsOutput = document.getElementById('companionsOutput');
// ДОБАВИТЬ ЭТИ СТРОКИ (можно в конец блока с DOM-элементами)
// НОВЫЕ ЭЛЕМЕНТЫ: Журналы
const recordsButton = document.getElementById('recordsButton');
const questsButton = document.getElementById('questsButton');
const charactersButton = document.getElementById('charactersButton');
const locationsButton = document.getElementById('locationsButton');
const recordsModal = document.getElementById('recordsModal');
const questsModal = document.getElementById('questsModal');
const charactersModal = document.getElementById('charactersModal');
const locationsModal = document.getElementById('locationsModal');
const closeRecordsBtn = document.getElementById('closeRecordsBtn');
const closeQuestsBtn = document.getElementById('closeQuestsBtn');
const closeCharactersBtn = document.getElementById('closeCharactersBtn');
const closeLocationsBtn = document.getElementById('closeLocationsBtn');
const recordsContent = document.getElementById('recordsContent');
const questsContent = document.getElementById('questsContent');
const charactersContent = document.getElementById('charactersContent');
const locationsContent = document.getElementById('locationsContent');
const questTabButtons = document.querySelectorAll('#questsModal .tab-button');
const questTabContents = document.querySelectorAll('#questsContent .quest-tab-content');

// New elements for character description modal
const characterDescriptionModal = document.getElementById('characterDescriptionModal');
const characterDescriptionContent = document.getElementById('characterDescriptionContent');
const closeCharDescriptionBtn = document.getElementById('closeCharDescriptionBtn');
const showCharacterDescriptionButton = document.createElement('button');
showCharacterDescriptionButton.id = 'showCharacterDescriptionButton';
showCharacterDescriptionButton.className = 'w-full mt-2 px-4 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500';
showCharacterDescriptionButton.innerHTML = '<i class="fas fa-user-alt"></i> О персонаже';
// New property modal elements
const propertyButton = document.getElementById('propertyButton');
const propertyModal = document.getElementById('propertyModal');
const closePropertyBtn = document.getElementById('closePropertyBtn');
const ownedHousesList = document.getElementById('housesList');
const ownedPlotsList = document.getElementById('plotsList');
const ownedFieldsList = document.getElementById('fieldsList');
const ownedBarnsList = document.getElementById('barnsList');
const ownedLivestockList = document.getElementById('livestockList');
const ownedVehiclesList = document.getElementById('vehiclesList');
// НОВОЕ: Элементы для интерактивной карты
const mapButton = document.getElementById('mapButton');
const mapModal = document.getElementById('mapModal');
const closeMapBtn = document.getElementById('closeMapBtn');
const mapContainer = document.getElementById('mapContainer');
const mapCanvas = document.getElementById('mapCanvas');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const resetViewBtn = document.getElementById('resetViewBtn');
        
        let currentTooltip = null; // Variable to hold the currently active tooltip element
        
        // Function to show custom message modal (replaces native alert/confirm)
        function showMessageModal(title, message, onConfirm = null) {
            console.log(`[showMessageModal] Title: ${title}, Message: ${message}`);
            messageModalTitle.textContent = title;
            messageModalContent.textContent = message;
            messageModal.classList.remove('hidden'); // Make modal visible
            messageModalConfirmBtn.onclick = () => {
                messageModal.classList.add('hidden'); // Hide modal on click
                if (onConfirm) onConfirm(); // Execute callback if provided
            };
        }
        
        // Displays a message in the main game output area
        function displayMessage(message, isCommand = false) {
            const p = document.createElement('p');
            p.classList.add('mb-2'); // Add margin-bottom for spacing
            p.innerHTML = isCommand ? `<span class="font-bold text-blue-700"> &gt; ${message}</span>` : message;
            gameOutput.appendChild(p);
            gameOutput.scrollTop = gameOutput.scrollHeight; // Auto-scroll to the latest message
        }

// НОВАЯ ФУНКЦИЯ: Логгирует действие, совершенное между ходами
function logInterTurnAction(message) {
    // Убедимся, что массив существует
    if (!gameState.narrative.interTurnLog) {
        gameState.narrative.interTurnLog = [];
    }
    // Добавляем сообщение в лог
    gameState.narrative.interTurnLog.push(message);
    
    // НЕ НУЖНО СОХРАНЯТЬ ИГРУ ЗДЕСЬ. 
    // Сохранение произойдет автоматически при следующем полноценном ходе (processCommand).
}
function logMoneyTransaction(amount, currency, reason, recipient = 'N/A') {
// Убедимся, что массив существует
if (!gameState.narrative.moneyLog) {
gameState.narrative.moneyLog = [];
}

// Получаем временную метку из состояния игры
const timestamp = `${gameState.world.currentDate}, ${gameState.world.currentTime}`;

// Добавляем новую запись в лог
gameState.narrative.moneyLog.push({
timestamp: timestamp,
turn: gameState.world.turnCounter, // Номер хода
amount: amount, // Сумма (может быть отрицательной)
currency: currency, // Валюта (copper, silver, gold)
reason: reason, // Причина (пока общая, от ИИ)
recipient: recipient // Получатель (пока не используется)
});

// Ограничиваем размер лога, чтобы он не рос бесконечно
// Будем хранить последние 200 транзакций
while (gameState.narrative.moneyLog.length > 200) {
gameState.narrative.moneyLog.shift(); // Удаляем самую старую запись
}

// Этот лог НЕ выводится игроку, он только сохраняется в gameState
console.log(`[MoneyLog] ${timestamp}: ${amount} ${currency} (Причина: ${reason})`);
}
        
        // Helper function to format location for display
function formatLocation(locationObj) {
    // Поддержка и нового 'name', и старого 'place'
    const locName = locationObj.name || locationObj.place;
    if (!locationObj || typeof locName !== 'string') return 'Неизвестно';
    
    let parts = [locName];
    if (locationObj.street) parts.push(`ул. ${locationObj.street}`);
    if (locationObj.city) parts.push(`г. ${locationObj.city}`);
    if (locationObj.district) parts.push(`р-н. ${locationObj.district}`);
    if (locationObj.worldPart) parts.push(`${locationObj.worldPart}`);
    return parts.filter(Boolean).join(', ');
}
        
        // Capitalizes the first letter of a given string
        function capitalizeFirstLetter(string) { return string.charAt(0).toUpperCase() + string.slice(1); }
        
        // Function to apply item effects (health, hunger, thirst, cleanliness etc.) to a target (player or companion)
function applyItemEffect(target, effect, value) {
if (!target) return; // Ensure target exists
let displayMessageText = '';
switch (effect) {
case 'restore_health':
target.health = Math.min(100, target.health + value);
displayMessageText = `Здоровье ${target.name || 'персонажа'} восстановлено на ${value} единиц.`;
break;
case 'restore_stamina':
target.stamina = Math.min(100, target.stamina + value);
displayMessageText = `Выносливость ${target.name || 'персонажа'} восстановлена на ${value} единиц.`;
break;
case 'hunger_reduction': // Eating reduces hunger (0 = not hungry, 100 = very hungry)
target.hunger = Math.max(0, target.hunger - value); // Reduced value means less hungry
displayMessageText = `${target.name || 'Персонаж'} стал менее голодным (Голод: -${value}).`;
break;
case 'thirst_reduction': // Drinking reduces thirst (0 = not thirsty, 100 = very thirsty)
target.thirst = Math.max(0, target.thirst - value); // Reduced value means less thirsty
displayMessageText = `${target.name || 'Персонаж'} стал менее жаждущим (Жажда: -${value}).`;
break;
case 'increase_cleanliness': // Washing increases cleanliness
target.cleanliness = Math.min(100, target.cleanliness + value);
displayMessageText = `${target.name || 'Персонаж'} стал чище (Чистота: +${value}).`;
break;
// Add more effects as needed
default:
console.warn(`Неизвестный эффект: ${effect}`);
break;
}
if (displayMessageText) {
logInterTurnAction(displayMessageText); // НОВОЕ: Записываем в журнал
displayMessage(displayMessageText);
}
// Assumed updateUI() exists and updates all relevant UI elements
if (typeof displayGameInfo === 'function') { // Using displayGameInfo as main UI update
displayGameInfo();
}
}
        // Function to handle using an item from inventory
function useItem(item, targetCompanionId = null) {
    if (!item || !item.type) {
        showMessageModal('Ошибка', 'Невозможно использовать этот предмет.');
        return;
    }

    // НЕ ПЫТАЕМСЯ "использовать" многоразовый контейнер через эту функцию.
    // Для этого есть кнопка "Пить" и функция drinkFromContainer.
    if (item.itemType === 'reusable_liquid_container') {
        showMessageModal('Действие', 'Чтобы выпить из этого, используйте кнопку "Пить".');
        return;
    }

    let target = gameState.player;
    let targetName = 'персонаж';
    if (targetCompanionId) {
        const companion = gameState.player.companions.find(c => c.id === targetCompanionId);
        if (companion) {
            target = companion;
            targetName = companion.name;
        } else {
            showMessageModal('Ошибка', 'Компаньон не найден.');
            return;
        }
    }

    if (item.type === 'consumable') {
        // Это для обычных расходуемых предметов (еда, одноразовые зелья)
        if (item.effects) {
            for (const effect in item.effects) {
                applyItemEffect(target, effect, item.effects[effect]);
            }

            // Корректно удаляем или уменьшаем предмет
            const itemIndex = gameState.player.inventory.findIndex(invItem => invItem.id === item.id);
            if (itemIndex !== -1) {
                if (gameState.player.inventory[itemIndex].quantity && gameState.player.inventory[itemIndex].quantity > 1) {
                    gameState.player.inventory[itemIndex].quantity--;
                } else {
                    gameState.player.inventory.splice(itemIndex, 1);
                }
            }
        } else {
            showMessageModal('Ошибка', 'У этого предмета нет определенных эффектов.');
        }

        saveGameState(); // Сохраняем состояние
        displayGameInfo(); // Обновляем UI

    } else {
        showMessageModal('Действие невозможно', 'Этот предмет нельзя использовать таким образом.');
    }
}
            
            
        // Function to equip an item
        function equipItem(item) {
            const player = gameState.player;
            // Determine the correct slot based on item.type or item.slot
            let targetSlot;
            if (item.slot) {
                targetSlot = item.slot;
            } else {
                // Infer slot from item.type if item.slot is not explicitly set by LLM
                switch (item.type) {
                    case 'head': targetSlot = 'head'; break;
                    case 'torso_clothing': targetSlot = 'torso_clothing'; break;
                    case 'torso_armor': targetSlot = 'torso_armor'; break;
                    case 'legs_clothing': targetSlot = 'legs_clothing'; break;
                    case 'legs_armor': targetSlot = 'legs_armor'; break;
                    case 'feet': targetSlot = 'feet'; break;
                    case 'weapon': targetSlot = 'weapon'; break;
                    case 'shield': targetSlot = 'shield'; break;
                    case 'amulet': targetSlot = 'amulet'; break;
                    case 'ring1': targetSlot = 'ring1'; break;
                    case 'ring2': targetSlot = 'ring2'; break;
                    default: showMessageModal('Ошибка', `Неизвестный слот для предмета: ${item.name}`); return;
                }
            }
            if (player.equippedItems[targetSlot]) {
                // If there's already an item in the slot, unequip it first
                unequipItem(targetSlot);
            }
            // Equip the new item
            player.equippedItems[targetSlot] = { ...item }; // Deep copy
            // Remove from inventory
            const itemIndex = player.inventory.findIndex(invItem => invItem.id === item.id);
            if (itemIndex !== -1) {
                player.inventory.splice(itemIndex, 1);
            }
            displayMessage(`Вы экипировали ${item.name}.`);
            saveGameState();
            displayGameInfo();
        }
        // Function to unequip an item
        function unequipItem(slotName) {
            const player = gameState.player;
            const equippedItem = player.equippedItems[slotName];
            if (equippedItem) {
                // Add the item back to inventory
                const existingItemInInventory = player.inventory.find(invItem => invItem.id === equippedItem.id);
                if (existingItemInInventory) {
                    if (equippedItem.quantity !== undefined) {
                        existingItemInInventory.quantity += equippedItem.quantity;
                    } else {
                        existingItemInInventory.quantity = (existingItemInInventory.quantity || 0) + 1;
                    }
                } else {
                    const newItem = { ...equippedItem };
                    // If it was a unique equipped item (no quantity field), set quantity to 1 for inventory
                    if (newItem.quantity === undefined) {
                        newItem.quantity = 1;
                    }
                    player.inventory.push(newItem);
                }
                player.equippedItems[slotName] = null; // Clear the slot
                displayMessage(`Вы сняли ${equippedItem.name}.`);
                saveGameState();
                displayGameInfo();
            } else {
                showMessageModal('Ошибка', `В слоте "${slotName}" ничего не надето.`);
            }
        }
// Обрабатывает питье из многоразового сосуда
function drinkFromContainer(item) {
console.log(`[drinkFromContainer] Попытка выпить из: ${item.name}`);
// 1. Проверяем, есть ли что пить
if (!item.contents || item.currentVolumeMl <= 0) {
showMessageModal('Сосуд пуст', 'Этот сосуд пуст. Его нужно наполнить.');
return;
}
const liquid = item.contents; // Получаем объект с жидкостью
const player = gameState.player;
// 2. Определяем, сколько выпить
const amountToDrink = 100; // Стандартная порция - 100 мл
const actualDrinkAmount = Math.min(amountToDrink, item.currentVolumeMl); // Нельзя выпить больше, чем есть
// 3. Рассчитываем и применяем эффекты
// Рассчитываем утоление жажды (предполагаем, что 'thirst_reduction' указан для 100 мл)
if (liquid.thirst_reduction) {
const thirstReductionValue = (liquid.thirst_reduction / 100) * actualDrinkAmount;
applyItemEffect(player, 'thirst_reduction', thirstReductionValue);
}
// Применяем любые другие эффекты от жидкости (например, восстановление здоровья от зелья)
if (liquid.effects && Array.isArray(liquid.effects)) {
liquid.effects.forEach(effectObj => {
// Рассчитываем эффект пропорционально выпитому
const effectValue = (effectObj.value / 100) * actualDrinkAmount;
applyItemEffect(player, effectObj.effect, effectValue);
});
}
// 4. Обновляем объем в сосуде
item.currentVolumeMl -= actualDrinkAmount;
item.fillPercentage = (item.currentVolumeMl / item.maxVolumeMl) * 100;
// 5. Проверяем, не опустел ли сосуд
if (item.currentVolumeMl <= 0) {
item.currentVolumeMl = 0;
item.contents = null; // Жидкость закончилась, удаляем объект с содержимым
item.fillPercentage = 0;
const emptyMessage = `Вы допили ${liquid.name} из ${item.name}. Сосуд теперь пуст.`;
logInterTurnAction(emptyMessage); // НОВОЕ: Записываем в журнал
displayMessage(emptyMessage);
} else {
const drinkMessage = `Вы отпили ${actualDrinkAmount} мл ${liquid.name} из ${item.name}. Осталось ${item.currentVolumeMl} мл.`;
logInterTurnAction(drinkMessage); // НОВОЕ: Записываем в журнал
displayMessage(drinkMessage);
}
// 6. Сохраняем и обновляем UI
saveGameState();
displayGameInfo(); // Это перерисует инвентарь с новыми данными
}
        
        // Generates detailed content for tooltips based on the item/object type
function getItemDetailsForTooltip(item) {
    let details = `<span class="font-bold text-lg">${item.name || item.title || item.place || (item.statusName || item.name) || item.type || 'Неизвестно'}</span><br>`;
    // Add description for all relevant items
    if (item.description) {
        details += `<span class="text-sm">${item.description}</span><br>`;
    }
    if (item.rarity) {
        let rarityColor = 'text-gray-400';
        if (item.rarity === 'uncommon') rarityColor = 'text-green-400';
        else if (item.rarity === 'rare') rarityColor = 'text-blue-400';
        else if (item.rarity === 'epic') rarityColor = 'text-purple-400';
        else if (item.rarity === 'legendary') rarityColor = 'text-yellow-400';
        details += `<span class="${rarityColor} text-sm">Редкость: ${capitalizeFirstLetter(item.rarity)}</span><br>`;
    }
    // Item details
    if (item.type && ['weapon', 'armor', 'torso', 'head', 'shield', 'amulet', 'ring1', 'ring2', 'torso_clothing', 'torso_armor', 'legs_clothing', 'legs_armor', 'feet', 'equipment'].includes(item.type)) { // Added 'equipment' type
        details += `<span class="text-sm">Тип: ${item.type || 'Разное'}</span><br>`;
        if (item.slot) details += `<span class="text-sm">Слот: ${capitalizeFirstLetter(item.slot)}</span><br>`; // Display slot if available
        if (item.type === 'weapon') {
            details += `<span class="text-sm">Урон: ${item.damage ? item.damage.min + '-' + item.damage.max : 'N/A'}</span><br>`;
            if (item.attackSpeed) details += `<span class="text-sm">Скорость: ${capitalizeFirstLetter(item.attackSpeed)}</span><br>`;
            if (item.range) details += `<span class="text-sm">Дальность: ${capitalizeFirstLetter(item.range)}</span><br>`;
        } else if (item.defense !== undefined) { // Check for defense on armor/clothing
            details += `<span class="text-sm">Защита: ${item.defense || 0}</span><br>`;
        }
        if (item.temperatureResistance !== undefined) {
            details += `<span class="text-sm">Термостойкость: ${item.temperatureResistance}°C</span><br>`;
        }
    } else if (item.type === 'consumable') {
        details += `<span class="text-sm">Тип: ${item.type}</span><br`;
        // --- НАЧАЛО ИЗМЕНЕНИЙ В ТУЛТИПЕ ---
        // Specific logic for reusable liquid containers (flasks)
        if (item.itemType === 'reusable_liquid_container') {
            const liquid = item.contents; // Получаем объект с жидкостью
            details += `<span class="text-sm">Содержимое: ${liquid ? liquid.name : 'Пусто'}</span><br>`;
            details += `<span class="text-sm">Объем: ${item.currentVolumeMl}мл / ${item.maxVolumeMl}мл</span><br>`;
            details += `<span class="text-sm">Заполнено: ${item.fillPercentage.toFixed(0)}%</span><br>`;

            if (liquid) {
                if (liquid.thirst_reduction) {
                    details += `<span class="text-sm">Утоляет жажду на ${liquid.thirst_reduction} (за 100мл).</span><br>`;
                }
                if (liquid.effects && Array.isArray(liquid.effects)) {
                    liquid.effects.forEach(effectObj => {
                        details += `<span class="text-sm">Эффект: ${effectObj.effect} (+${effectObj.value} за 100мл)</span><br>`;
                    });
                }
            }
            // --- КОНЕЦ ИЗМЕНЕНИЙ В ТУЛТИПЕ ---
        } else { // Generic consumable
            if (item.effects) {
                for (const effect in item.effects) {
                    let effectName = '';
                    if (effect === 'health_restoration') effectName = 'Восстанавливает Здоровье';
                    else if (effect === 'stamina_restoration') effectName = 'Восстанавливает Выносливость';
                    else if (effect === 'hunger_reduction') effectName = 'Уменьшает Голод';
                    else if (effect === 'thirst_reduction') effectName = 'Уменьшает Жажду';
                    else if (effect === 'increase_cleanliness') effectName = 'Увеличивает Чистоту';
                    else effectName = effect; // Fallback
                    details += `<span class="text-sm">Эффект: ${effectName} (${item.effects[effect]})</span><br>`;
                }
            }
            if (item.quantity !== undefined) details += `<span class="text-sm">Кол-во: ${item.quantity}</span><br>`;
        }
    }
    // Skill details
    else if (item.type === 'skill') {
        details = `<span class="font-bold text-lg">${item.name}</span><br>`;
        details += `<span class="text-sm">Уровень: ${item.level}</span><br>`;
        if (item.maxLevel !== undefined) details += `<span class="text-sm">Макс. Уровень: ${item.maxLevel}</span><br>`;
    }
    // NPC details
    else if (item.type === 'npc' || item.type === 'enemy') {
        details = `<span class="font-bold text-lg">${item.name}</span><br>`;
        if (item.lastMetAt && item.lastMetAt.location && item.lastMetAt.time && item.lastMetAt.date) {
            details += `<span class="text-sm">Последняя встреча: ${item.lastMetAt.location} (${item.lastMetAt.time}, ${item.lastMetAt.date})</span><br>`;
        }
    }
    // MODIFIED: Companion details simplified
    else if (item.type === 'companion') {
        details = `<span class="font-bold text-lg">${item.name} (${item.species})</span><br>`;
        if (item.description) details += `<span class="text-sm">${item.description}</span><br>`;
        if (item.health !== undefined) details += `<span class="text-sm">Здоровье: ${item.health}%</span><br>`;
        if (item.hunger !== undefined) details += `<span class="text-sm">Голод: ${item.hunger}%</span><br>`;
        if (item.thirst !== undefined) details += `<span class="text-sm">Жажда: ${item.thirst}%</span><br>`;
        // REMOVED: loyalty and cleanliness tooltips are gone
        if (item.status && item.status.length > 0) {
            details += `<span class="text-sm">Статус: ${item.status.map(s => capitalizeFirstLetter(s)).join(', ')}</span><br>`;
        }
    }
    // Location details - ОБНОВЛЕННЫЙ БЛОК
    else if (item.type === 'location') {
        // Используем name, если есть, иначе place
        const locName = item.name || item.place || 'Без названия';
        details = `<span class="font-bold text-lg">${locName}</span><br>`;
        if (item.street) details += `<span class="text-sm">Улица: ${item.street}</span><br>`;
        if (item.city) details += `<span class="text-sm">Город: ${item.city}</span><br>`;
        if (item.district) details += `<span class="text-sm">Район: ${item.district}</span><br>`;
        if (item.worldPart) details += `<span class="text-sm">Часть мира: ${item.worldPart}</span><br>`;
    }
    // Lore details
    else if (item.type === 'lore') {
        details = `<span class="font-bold text-lg">${item.title}</span><br>`;
    }
    // Slot details
    else if (item.type === 'slot') {
        details = `<span class="font-bold text-lg">${item.name}</span><br>`;
    }
    // Status details - UPDATED
    else if (item.type === 'status') {
        details = `<span class="font-bold text-lg">${item.name}</span><br>`;
        if (item.duration !== undefined && item.duration !== Infinity && item.duration > 0) {
            details += `<span class="text-sm">Осталось ходов: ${item.duration}</span><br>`;
        } else if (item.duration === Infinity) {
            details += `<span class="text-sm">Длительность: Бесконечно</span><br>`;
        } else {
            details += `<span class="text-sm">Длительность: Заканчивается</span><br>`; // Or 'Уже закончился'
        }
    } else if (item.type === 'comfort_status') {
        // This is specifically for the comfort tooltip, using data from LLM's playerUpdate.comfortInfo
        details = `<span class="font-bold text-lg">Комфорт</span><br>`;
        details += `<span class="text-sm">Статус: ${item.statusName}</span><br>`;
        details += `<span class="text-sm">Температура воздуха: ${item.currentTemp}°C</span><br>`;
        details += `<span class="text-sm">Сопротивление одежды: ${item.clothingResistance}°C</span><br>`;
        if (item.hasWarmSource) details += `<span class="text-sm">Рядом источник тепла: Да</span><br>`;
        if (item.hotFoodBonus) details += `<span class="text-sm">Бонус от горячей еды: ${item.hotFoodBonus}°C</span><br>`;
        details += `<span class="text-sm">Эффективная температура: ${item.effectiveTemperature.toFixed(1)}°C</span><br>`;
    }
    else if (item.type === 'notebook_event') {
        details = `<span class="font-bold text-lg">${item.title || item.name || 'Событие'}</span><br>`;
        details += `<span class="text-sm">${item.description || 'Нет описания.'}<br>`;
        if (item.source) details += `<span class="text-sm">Источник: ${item.source}</span><br>`;
    } else if (item.type === 'notebook_character') {
        details = `<span class="font-bold text-lg">${item.name || 'Безымянный персонаж'}</span><br>`;
        details += `<span class="text-sm">${item.description || 'Нет описания.'}</span><br>`;
        if (item.source) details += `<span class="text-sm">Источник: ${item.source}</span><br>`;
    } else if (item.type === 'notebook_location') {
        details = `<span class="font-bold text-lg">${item.name || 'Неизвестное место'}</span><br>`;
        details += `<span class="text-sm">${item.description || 'Нет описания.'}</span><br>`;
        if (item.directions) details += `<span class="text-sm">Как добраться: ${item.directions}</p>`;
        if (item.distance) details += `<span class="text-sm">Расстояние: ${item.distance}</span><br>`;
        if (item.source) details += `<span class="text-sm">Источник: ${item.source}</span><br>そうです。`;
    } else if (item.type === 'notebook_quest') {
        details = `<span class="font-bold text-lg">${item.title || item.name || 'Задание'}</span><br>`;
        details += `<span class="text-sm">${item.description || 'Нет описания.'}</p>`;
        if (item.giver) details += `<span class="text-sm">Дано: ${item.giver}</span><br>`;
        if (item.objectives && item.objectives.length > 0) {
            details += `<span class="text-sm">Задачи: <ul>`;
            item.objectives.forEach(obj => details += `<li>- ${obj}</li>`);
            details += `</ul></span>`;
        }
        if (item.location) details += `<span class="text-sm">Место: ${item.location}</span><br>`;
        if (item.turnInTo) details += `<span class="text-sm">Сдать: ${item.turnInTo}</span><br>`;
        if (item.reward) details += `<span class="text-sm">Награда: ${item.reward}</span><br>`; // Added reward
        if (item.importantInfo) details += `<span class="text-sm">Важная инф.: ${item.importantInfo}</span><br>`;
    }
    // Property details
    else if (item.type && ['house', 'plot', 'field', 'barn', 'livestock', 'vehicle'].includes(item.type)) {
        details = `<span class="font-bold text-lg">${item.name || 'Неизвестное имущество'}</span><br>`;
        details += `<span class="text-sm">Тип: ${item.type === 'house' ? 'Дом' : item.type === 'plot' ? 'Участок' : item.type === 'field' ?
            'Поле' : item.type === 'barn' ? 'Сарай' : item.type === 'livestock' ? 'Скот' : item.type === 'vehicle' ?
                'Повозка' : capitalizeFirstLetter(item.type)}</span><br>`;
        if (item.location) details += `<span class="text-sm">Местоположение: ${item.location}</span><br>`;
        if (item.value) details += `<span class="text-sm">Стоимость: ${item.value} монет</span><br>`;
        if (item.production) details += `<span class="text-sm">Производство: ${item.production}</span><br>`;
        if (item.capacity) details += `<span class="text-sm">Вместимость: ${item.capacity}</span><br>`;
    }
    // Universal description at the end, if not already added.
    if (item.description && !details.includes(item.description)) {
        details += `<span class="text-sm">${item.description}</span>`;
    }
    return details;
}
        
        // Displays a tooltip near the mouse cursor
        function showTooltip(event, data, type) {
            event.stopPropagation(); // Prevent event from bubbling up
            hideTooltip(); // Hide any existing tooltip first
            const targetElement = event.currentTarget;
            const rect = targetElement.getBoundingClientRect(); // Get position of the element
            currentTooltip = document.createElement('div');
            currentTooltip.className = 'game-tooltip';
            currentTooltip.innerHTML = getItemDetailsForTooltip({ ...data, type });
            document.body.appendChild(currentTooltip);
            // Position the tooltip after it's added to the DOM to calculate its dimensions
            const tooltipWidth = currentTooltip.offsetWidth;
            const tooltipHeight = currentTooltip.offsetHeight;
            let left = rect.left + (rect.width / 2);
            let top = rect.top - tooltipHeight - 10; // Default to above
            // Check for horizontal overflow and adjust
            if (left - tooltipWidth / 2 < 5) { // Off left edge
                left = 5; // Align to left edge with some padding
            } else if (left + tooltipWidth / 2 > window.innerWidth - 5) { // Off right edge
                left = window.innerWidth - tooltipWidth - 5; // Align to right edge with some padding
            } else {
                left = left - tooltipWidth / 2; // Center it
            }
            // Check for vertical overflow (if it goes off top, move to bottom)
            if (top < 5) {
                top = rect.bottom + 10; // Position below the element
            }
            currentTooltip.style.left = `${left}px`;
            currentTooltip.style.top = `${top}px`;
            currentTooltip.classList.add('visible'); // Make it visible
            document.addEventListener('click', hideTooltipOnClickOutside); // Hide tooltip on outside click
        }
        
        // Hides the currently active tooltip
        function hideTooltip() {
            if (currentTooltip) {
                currentTooltip.classList.remove('visible'); // Start fade out animation
                setTimeout(() => {
                    // Remove from DOM after animation
                    if (currentTooltip) { // Check again in case it was re-shown and then hidden quickly
                        currentTooltip.remove();
                        currentTooltip = null;
                        document.removeEventListener('click', hideTooltipOnClickOutside);
                    }
                }, 200); // Match CSS transition duration
            }
        }
        
        // Event handler to hide tooltip when clicking outside any relevant element
        function hideTooltipOnClickOutside(event) {
            // Check if the click target or any of its ancestors is not a tooltip trigger or the tooltip/modal itself
        
            if (currentTooltip && !event.target.closest('.skill-item') && !event.target.closest('.inventory-item') &&
                !event.target.closest('.npc-item') && !event.target.closest('.location-item') &&
                !event.target.closest('.lore-item') && !event.target.closest('.equipment-list-item') &&
                !event.target.closest('.status-item') && !event.target.closest('.game-tooltip') &&
                !event.target.closest('.companion-item') &&
                
                !event.target.closest('.notebook-entry') &&
                !event.target.closest('.modal')) {
                hideTooltip();
            }
        }
        
        // Updates the player's status displays (health, stamina, hunger, etc.) and inventory/skills/equipment
function updateStatus() {
// Add a defensive check to ensure gameState.player exists
if (!gameState || !gameState.player) {
console.warn("gameState или gameState.player не определены во время updateStatus. Пропускаем обновление UI.");
return;
}
// Update main game title and page title
gameTitleEl.textContent = gameState.gameTitle;
gamePageTitle.textContent = gameState.gameTitle;
// Update health bar
playerHealthEl.textContent = `${Math.round(gameState.player.health)}%`;
healthBarEl.style.width = `${gameState.player.health}%`;
healthBarEl.className = `progress-bar ${gameState.player.health < 30 ? 'bg-red-500' : 'bg-green-500'}`;
// Update stamina bar
playerStaminaEl.textContent = `${Math.round(gameState.player.stamina)}%`;
staminaBarEl.style.width = `${gameState.player.stamina}%`;
staminaBarEl.className = `progress-bar ${gameState.player.stamina < 30 ? 'bg-orange-500' : 'bg-blue-500'}`;
// Update hunger bar (0 = not hungry, 100 = very hungry)
playerHungerEl.textContent = `${Math.round(gameState.player.hunger)}%`;
hungerBarEl.style.width = `${100 - gameState.player.hunger}%`; // Bar fills from right to left (less hungry)
hungerBarEl.className = `progress-bar ${gameState.player.hunger > 70 ? 'bg-red-500' : 'hunger-bar'}`;
// Update thirst bar (0 = not thirsty, 100 = very thirsty)
playerThirstEl.textContent = `${Math.round(gameState.player.thirst)}%`;
thirstBarEl.style.width = `${100 - gameState.player.thirst}%`; // Bar fills from right to left (less thirsty)
thirstBarEl.className = `progress-bar ${gameState.player.thirst > 70 ? 'bg-red-500' : 'thirst-bar'}`;
// Update cleanliness bar
playerCleanlinessEl.textContent = `${Math.round(gameState.player.cleanliness)}%`;
cleanlinessBarEl.style.width = `${gameState.player.cleanliness}%`;
cleanlinessBarEl.className = `progress-bar ${gameState.player.cleanliness < 30 ? 'bg-red-500' : 'cleanliness-bar'}`;
// Update XP and Level
playerXP_El.textContent = `${gameState.player.xp} / ${getXpForNextLevel(gameState.player.level)}`;
xpBarEl.style.width = `${(gameState.player.xp / getXpForNextLevel(gameState.player.level)) * 100}%`;
playerLevel_El.textContent = gameState.player.level;
skillPointsEl.textContent = gameState.player.skillPoints;
// Update money display (all three currencies)
playerMoneyCopperEl.textContent = `${gameState.player.money.copper} медных`;
playerMoneySilverEl.textContent = `${gameState.player.money.silver} серебряных`;
playerMoneyGoldEl.textContent = `${gameState.player.money.gold} золотых`;
// =======================================================
// ИСПРАВЛЕНИЕ ОТОБРАЖЕНИЯ СТАТУСОВ
// =======================================================
playerStatusesEl.innerHTML = '';
// Проверяем, что статусы существуют и являются массивом
if (gameState.player.statuses && Array.isArray(gameState.player.statuses)) {
gameState.player.statuses.forEach(status => {
// Дополнительная проверка, что статус - это объект с именем
if (status && typeof status.name === 'string') {
const span = document.createElement('span');
span.classList.add('bg-purple-100', 'text-purple-800', 'px-1', 'py-0.5', 'rounded-full', 'text-xs', 'mr-1', 'cursor-pointer', 'status-item');
let statusText = status.name;
if (status.duration !== undefined && status.duration !== Infinity && status.duration > 0) {
statusText += ` (${status.duration} ход.)`;
} else if (status.duration === Infinity) {
statusText += ` (Бесконечно)`;
}
span.textContent = statusText;
span.addEventListener('click', (event) => showTooltip(event, status, 'status'));
playerStatusesEl.appendChild(span);
}
});
}
// =======================================================
// Update player inventory display
playerInventoryEl.innerHTML = '';
gameState.player.inventory.forEach(item => {
const li = document.createElement('li');
li.className = 'inventory-item cursor-pointer text-gray-800 hover:text-gray-600 flex items-center';
let itemDisplayName = item.name;
// --- НАЧАЛО ИЗМЕНЕНИЙ В ИНВЕНТАРЕ ---
// Специальное отображение для многоразовых сосудов
if (item.itemType === 'reusable_liquid_container') {
const liquidName = item.contents ? item.contents.name : 'Пусто';
itemDisplayName = `${item.name} (${liquidName}: ${item.currentVolumeMl}/${item.maxVolumeMl} мл)`;
} else if (item.quantity) {
// Обычное отображение количества для других предметов
itemDisplayName += ` (${item.quantity})`;
}
if (item.owner) {
itemDisplayName += ` (${item.owner})`;
}
li.innerHTML = `<span>${itemDisplayName}</span>`;
const isEquipped = Object.values(gameState.player.equippedItems).some(equipped => equipped && equipped.id === item.id);
// НОВАЯ ЛОГИКА КНОПОК
if (item.itemType === 'reusable_liquid_container' && item.contents && item.currentVolumeMl > 0) {
// 1. Если это сосуд И в нем есть жидкость -> СИНЯЯ КНОПКА "ПИТЬ"
const drinkButton = document.createElement('button');
// Используем классы Tailwind для синей кнопки
drinkButton.className = 'ml-2 px-2 py-0.5 bg-blue-500 text-white text-xs rounded-md hover:bg-blue-600';
drinkButton.textContent = 'Пить';
drinkButton.addEventListener('click', (e) => {
e.stopPropagation();
drinkFromContainer(item); // Вызываем новую функцию (ВОЗВРАЩАЕМ КАК БЫЛО)
});
li.appendChild(drinkButton);
} else if (item.type === 'consumable' && item.itemType !== 'reusable_liquid_container') {
// 2. Если это ОБЫЧНЫЙ расходуемый предмет (не сосуд) -> ЗЕЛЕНАЯ КНОПКА "ИСПОЛЬЗОВАТЬ"
const useButton = document.createElement('button');
useButton.classList.add('use-btn'); // Старая зеленая кнопка
useButton.textContent = 'Использовать';
useButton.addEventListener('click', (e) => {
e.stopPropagation();
useItem(item); // Вызываем старую функцию (ВОЗВРАЩАЕМ КАК БЫЛО)
});
li.appendChild(useButton);
} else if (item.type === 'equipment' && !isEquipped) {
// 3. Если это экипировка -> СИНЯЯ КНОПКА "НАДЕТЬ"
const equipButton = document.createElement('button');
equipButton.classList.add('ml-2', 'px-2', 'py-0.5', 'bg-blue-500', 'text-white', 'text-xs', 'rounded-md', 'hover:bg-blue-600');
equipButton.textContent = 'Надеть';
equipButton.addEventListener('click', (e) => {
e.stopPropagation();
equipItem(item);
});
li.appendChild(equipButton);
}
// --- КОНЕЦ ИЗМЕНЕНИЙ В ИНВЕНТАРЕ ---
li.addEventListener('click', (event) => showTooltip(event, item, item.type || 'misc'));
playerInventoryEl.appendChild(li);
});
// Update player skills display
playerSkillsEl.innerHTML = '';
gameState.player.skills.forEach(skill => {
const li = document.createElement('li');
li.className = 'skill-item cursor-pointer text-blue-600 hover:text-blue-800 flex items-center';
li.innerHTML = `<span>${skill.name} (Ур. ${skill.level} / ${skill.maxLevel || '∞'})</span>`;
if (skill.upgradable && gameState.player.skillPoints > 0 && (skill.level < (skill.maxLevel || Infinity))) {
const upgradeButton = document.createElement('button');
upgradeButton.classList.add('ml-2', 'px-2', 'py-0.5', 'bg-green-500', 'text-white', 'text-xs', 'rounded-md', 'hover:bg-green-600');
upgradeButton.textContent = 'Улучшить';
upgradeButton.addEventListener('click', (e) => {
e.stopPropagation();
processCommand(`Улучшить навык ${skill.name}`);
});
li.appendChild(upgradeButton);
}
li.addEventListener('click', (event) => showTooltip(event, skill, 'skill'));
playerSkillsEl.appendChild(li);
});
updateEquipmentDisplay();
}
        
        // Updates the display of equipped items in specific slots
        function updateEquipmentDisplay() {
            const player = gameState.player;
            // Define the complete list of slots with their localized names and icons
            const equipmentSlots = [
                { id: 'head', label: 'Голова', icon: 'fas fa-hat' },
                { id: 'torso_clothing', label: 'Одежда на торс', icon: 'fas fa-tshirt' },
                { id: 'torso_armor', label: 'Броня на торс', icon: 'fas fa-vest-patches' },
                { id: 'legs_clothing', label: 'Одежда на ноги', icon: 'fas fa-shoe-prints' },
                { id: 'legs_armor', label: 'Броня на ноги', icon: 'fas fa-user-shield' },
                { id: 'feet', label: 'Обувь', icon: 'fas fa-socks' },
                { id: 'weapon', label: 'Оружие', icon: 'fas fa-sword' },
                { id: 'shield', label: 'Щит', icon: 'fas fa-shield-alt' },
                { id: 'amulet', label: 'Амулет', icon: 'fas fa-gem' },
                { id: 'ring1', label: 'Кольцо 1', icon: 'fas fa-ring' },
                { id: 'ring2', label: 'Кольцо 2', icon: 'fas fa-ring' },
            ];
            equipmentSlots.forEach(slotInfo => {
                const li = document.querySelector(`.equipment-list-item[data-slot="${slotInfo.id}"]`);
                if (!li) return; // Skip if the element doesn't exist (shouldn't happen with updated HTML)
                const spanElement = li.querySelector('span');
                const unequipButton = li.querySelector('.unequip-btn');
           
                const iconElement = li.querySelector('i');
                const equippedItem = player.equippedItems[slotInfo.id];
                
                if (iconElement) { // Update icon to match slotInfo, or item's custom icon
                    iconElement.className = `fas ${equippedItem && equippedItem.icon ? equippedItem.icon : slotInfo.icon}`;
                }
                if (equippedItem) {
                    spanElement.innerHTML = `${slotInfo.label}: <span class="font-medium">${equippedItem.name}</span>`;
                    if (unequipButton) {
                    
                        unequipButton.style.display = 'inline-block';
                        // Re-attach event listener to avoid duplicates from previous updates
                        const newUnequipButton = unequipButton.cloneNode(true);
                        unequipButton.parentNode.replaceChild(newUnequipButton, unequipButton);
                        newUnequipButton.addEventListener('click', (e) => {
                            e.stopPropagation();
                            unequipItem(slotInfo.id);
                        });
                    }
                    li.addEventListener('click', (event) => showTooltip(event, equippedItem, equippedItem.type));
                } else {
                    spanElement.innerHTML = `${slotInfo.label}: <span class="font-medium">Ничего</span>`;
                    if (unequipButton) {
                        unequipButton.style.display = 'none';
                    }
                    // For empty slots, show a generic slot tooltip
                    li.addEventListener('click', (event) => showTooltip(event, { name: slotInfo.label, description: `Пустой слот для ${slotInfo.id}`, type: 'slot', slot: slotInfo.id }, 'slot'));
                }
            });
        }
                
// Обновляет панель "Окружение"
function updateSurroundingsDisplay() {
    // Добавляем проверку, что gameState и gameState.narrative существуют
    if (!gameState || !gameState.narrative) {
        console.warn("gameState или gameState.narrative не определены во время updateSurroundingsDisplay.");
        return;
    }

    // Используем глобальную переменную surroundingsOutput, определенную в блоке DOM-ссылок
    if (surroundingsOutput) {
        surroundingsOutput.innerHTML = ''; // Очищаем панель
        const p = document.createElement('p');
        p.classList.add('text-gray-700'); // Добавляем класс для стилизации текста
        
        // Используем textContent для безопасной вставки текста.
        // Он возьмет описание из gameState.narrative.sceneDescription
        // или покажет заглушку, если оно пустое.
        p.textContent = gameState.narrative.sceneDescription || 'Описание окружения неясно.';
        
        surroundingsOutput.appendChild(p); // Добавляем текст в панель
    } else {
        // Эта ошибка появится в консоли, если мы забыли определить surroundingsOutput в DOM-ссылках
        console.warn("Элемент #surroundingsOutput не найден.");
    }
}
        
        // MODIFIED: Updates the companions display (simplified)
function updateCompanionsDisplay() {
            companionsOutput.innerHTML = '';
            if (gameState.player.companions && gameState.player.companions.length > 0) {
                gameState.player.companions.forEach(companion => {
                    const companionEl = document.createElement('div');
                    companionEl.classList.add('companion-item', 'mb-1', 'cursor-pointer', 'p-1', 'bg-gray-100', 'rounded', 'hover:bg-gray-200');
                    companionEl.dataset.itemId = companion.id || companion.name;
                    companionEl.dataset.itemType = 'companion';
                    
                    let statusHtml = '';
                    // Новая логика: просто выводим статусы из массива.
                    // Промпт теперь требует, чтобы они были на русском.
                    if (companion.status && companion.status.length > 0) {
                        statusHtml = companion.status.map(s => `<span class="ml-1 text-xs italic text-red-700">${s}</span>`).join('');
                    }
                    
                    companionEl.innerHTML = `<span class="font-medium">${companion.name} (${companion.species || 'неизвестно'})</span>${statusHtml}`;
                    companionEl.addEventListener('click', (event) => showTooltip(event, companion, 'companion'));
                    companionsOutput.appendChild(companionEl);
                });
            } else {
                companionsOutput.innerHTML = '<p class="text-xs italic text-gray-500">Пока нет компаньонов.</p>';
            }
        }
        
// Updates the event log display, showing recent game events
        function updateEventLogDisplay() {
            eventLogOutput.innerHTML = '';
            // Проверяем, что eventLog существует и является массивом
            if (gameState.narrative && Array.isArray(gameState.narrative.eventLog) && gameState.narrative.eventLog.length > 0) {
                // Используем slice() для создания копии, чтобы reverse() не изменял исходный массив
                gameState.narrative.eventLog.slice().reverse().forEach(entry => {
                    if (typeof entry === 'string' && entry.trim() !== '') {
                        const p = document.createElement('p');
                        p.classList.add('mb-1', 'text-gray-700');
                        // Используем textContent для безопасного вывода текста
                        p.textContent = `• ${entry}`;
                        eventLogOutput.appendChild(p);
                    }
                });
            } else {
                eventLogOutput.innerHTML = '<p class="text-gray-500 italic">Журнал событий пуст.</p>';
            }
            // Прокручиваем в самый низ, чтобы были видны последние события
            eventLogOutput.scrollTop = eventLogOutput.scrollHeight;
        }
        
        // Renders dynamic action options as clickable buttons
function renderDynamicOptions() {
    dynamicOptionsDiv.innerHTML = ''; // Clear previous options

    // НОВАЯ ЛОГИКА: Проверка на опции оплаты
    if (gameState.narrative.paymentOptions && gameState.narrative.paymentOptions.amount > 0) {
        const payment = gameState.narrative.paymentOptions;
        
        // Зеленая кнопка "Оплатить"
        const payButton = document.createElement('button');
        payButton.className = 'px-4 py-2 bg-green-600 text-white font-semibold rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-400 text-sm';
        payButton.textContent = `Оплатить (${payment.amount} ${payment.currency})`;
        payButton.addEventListener('click', () => {
            const command = `Оплатить ${payment.amount} ${payment.currency} персонажу ${payment.recipient}`;
            commandInput.value = command;
            submitCommandBtn.click();
        });
        dynamicOptionsDiv.appendChild(payButton);

        // Красная кнопка "Отказаться"
        const declineButton = document.createElement('button');
        declineButton.className = 'px-4 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-400 text-sm';
        declineButton.textContent = 'Отказаться';
        declineButton.addEventListener('click', () => {
            commandInput.value = 'Отказаться от сделки';
            submitCommandBtn.click();
        });
        dynamicOptionsDiv.appendChild(declineButton);

    } else {
        // Стандартная логика для обычных опций
        const defaultOptions = ["Осмотреться", "Послушать", "Понюхать", "Идти дальше"];
        const currentSceneOptions = Array.isArray(gameState.narrative.currentScene.options) ? gameState.narrative.currentScene.options : [];
        const combinedOptions = [...new Set([...currentSceneOptions, ...defaultOptions])];
        
        combinedOptions.forEach(optionText => {
            const button = document.createElement('button');
            button.className = 'px-4 py-2 bg-gray-200 text-gray-800 font-semibold rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 text-sm';
            button.textContent = optionText;
            button.addEventListener('click', () => {
                commandInput.value = optionText;
                submitCommandBtn.click();
            });
            dynamicOptionsDiv.appendChild(button);
        });
    }
}
        
        // Updates the combat information display when in combat
        function updateCombatDisplay() {
            if (gameState.world.inCombat && gameState.world.combat.enemies && gameState.world.combat.enemies.length > 0) {
                combatInfoDiv.classList.remove('hidden'); // Show combat info panel
                enemyStatusEl.innerHTML = ''; // Clear previous enemy status
                
                gameState.world.combat.enemies.forEach(enemy => {
                    const enemyDiv = document.createElement('div');
                    enemyDiv.classList.add('flex-auto', 'min-w-0'); // Allows wrapping, min-width for small screens
           
                    // Display enemy name and health, with color coding for health
                    enemyDiv.innerHTML = `Противник: <span class="font-bold">${enemy.name}</span> | Здоровье: <span class="${enemy.health < enemy.maxHealth / 3 ? 'text-red-600' : 'text-green-600'}">${enemy.health}/${enemy.maxHealth}</span>`;
                    enemyStatusEl.appendChild(enemyDiv);
                });
                combatLogEl.innerHTML = ''; // Clear previous combat log entries
                gameState.world.combat.log.forEach(entry => {
                    const p = document.createElement('p');
                    p.classList.add('text-xs', 'mb-0.5');
                    p.textContent = `• ${entry}`;
       
                    combatLogEl.appendChild(p);
                });
                combatLogEl.scrollTop = combatLogEl.scrollHeight; // Auto-scroll to latest log
            } else {
                combatInfoDiv.classList.add('hidden'); // Hide combat info panel if not in combat
            }
        }
        
        // Updates the character's current thoughts display
        function updateSlavaThoughtsDisplay() {
            thoughtsPanelTitle.innerHTML = `Твои мысли <i class="fas fa-brain text-yellow-600"></i>`; // Set panel title
            characterCurrentThought.textContent = gameState.narrative.slavaThoughts || 'Пока никаких мыслей...'; // Display current thought
            thoughtsPanel.classList.remove('hidden'); // Ensure thoughts panel is visible
        }
        
        // Renders a simple text-based map based on known locations and connections
function renderInteractiveMap() {
    const svg = document.getElementById('mapCanvas');
    if (!svg) {
        console.warn("Элемент #mapCanvas не найден.");
        return;
    }
    // Полностью очищаем карту перед новой отрисовкой
    svg.innerHTML = ''; 
    
    // Получаем список известных локаций из дневника игрока
    const notebookLocations = gameState.world.knownLocations || [];
    // Получаем все локации, которые существуют в мире игры
    const allMapLocations = gameState.world._globalLore.map.locations || {};

    // Создаем множество (Set) для быстрого поиска известных названий локаций
    const knownLocationNames = new Set(notebookLocations.map(note => note.name));
    
    // Фильтруем все локации мира, оставляя только те, что известны игроку
    const knownLocationsData = Object.values(allMapLocations).filter(loc => knownLocationNames.has(loc.place));

    // Если игроку не известно ни одной локации, показываем сообщение
    if (knownLocationsData.length === 0) {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '50%');
        text.setAttribute('y', '50%');
        text.setAttribute('text-anchor', 'middle');
        text.textContent = 'Карта пуста. Исследуйте мир, чтобы открывать новые места.';
        svg.appendChild(text);
        return;
    }

    // Группируем локации по их родительским объектам (например, таверна внутри города)
    const locationTree = {};
    knownLocationsData.forEach(loc => {
        // Если у локации нет родителя, она относится к главной "canvas" (холсту)
        const parent = loc.parentLocation || 'canvas'; 
        if (!locationTree[parent]) {
            locationTree[parent] = [];
        }
        locationTree[parent].push(loc);
    });

    // Создаем SVG-группы для разных слоев карты
    const regionsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const connectionsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const locationsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    // Отрисовка регионов, к которым принадлежат известные локации
    const knownRegions = [...new Set(knownLocationsData.map(loc => loc.region))];
    const allRegionsData = gameState.world._globalLore.regions || {};
    
    knownRegions.forEach(regionName => {
        const regionData = allRegionsData[regionName];
        if (!regionData) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', regionData.path); // Предполагаем, что в данных региона есть SVG path
        path.classList.add('region-shape');
        regionsGroup.appendChild(path);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', regionData.label_x);
        text.setAttribute('y', regionData.label_y);
        text.textContent = regionData.name;
        text.classList.add('region-label');
        regionsGroup.appendChild(text);
    });

    // Отрисовка соединений между известными локациями
    const drawnConnections = new Set();
    knownLocationsData.forEach(loc => {
        if (!loc.connections) return;
        loc.connections.forEach(conn => {
            const targetLoc = knownLocationsData.find(kld => kld.place === conn.to);
            if (targetLoc) {
                const pair1 = `${loc.place}-${targetLoc.place}`;
                const pair2 = `${targetLoc.place}-${loc.place}`;
                if (!drawnConnections.has(pair1) && !drawnConnections.has(pair2)) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', loc.x);
                    line.setAttribute('y1', loc.y);
                    line.setAttribute('x2', targetLoc.x);
                    line.setAttribute('y2', targetLoc.y);
                    line.classList.add('connection-line');
                    connectionsGroup.appendChild(line);
                    drawnConnections.add(pair1);
                }
            }
        });
    });

// Главная рекурсивная функция для отрисовки локации и всех её дочерних элементов
function renderLocation(loc, parentGroup) {
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.classList.add('location-group', 'cursor-pointer');
    group.setAttribute('transform', `translate(${loc.x || 0}, ${loc.y || 0})`);

    // Добавляем класс для управления видимостью в зависимости от уровня зума
    if (loc.zoomLevel) {
        group.classList.add(`zoom-level-${loc.zoomLevel}`);
    }
    // Если это текущая локация игрока, добавляем специальный класс
    if (loc.place === gameState.world.currentLocation.place) {
        group.classList.add('current-location');
    }
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    // Мелкие объекты (уровень зума > 1) будут иметь меньший кружок
    circle.setAttribute('r', loc.zoomLevel > 1 ? '5' : '8');
    circle.classList.add('location-circle');

    // Раскрашиваем кружок в зависимости от типа локации
    if (loc.type && loc.type.includes('city')) {
        circle.classList.add('location-city');
    } else if (loc.type && loc.type.includes('forest')) {
        circle.classList.add('location-forest');
    } else {
        circle.classList.add('location-default');
    }

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.textContent = loc.place;
    label.setAttribute('y', '22'); // Смещаем подпись под кружок
    label.setAttribute('text-anchor', 'middle'); // Центрируем текст
    label.classList.add('location-label');

    group.appendChild(circle);
    group.appendChild(label);
    // Добавляем звездочку для текущей локации игрока
    if (loc.place === gameState.world.currentLocation.place) {
        const star = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        star.textContent = '★';
        star.setAttribute('y', '5');
        star.setAttribute('x', '0');
        star.setAttribute('text-anchor', 'middle');
        star.classList.add('current-location-star');
        group.appendChild(star);
    }

    // --- ИСПРАВЛЕНО ЗДЕСЬ ---
    // Привязываем события мыши: показ/скрытие подсказки и приближение по клику
    group.addEventListener('mouseenter', (e) => showLocationTooltip(e, loc));
    group.addEventListener('mouseleave', hideLocationTooltip); // Теперь эта функция существует
    group.addEventListener('click', () => {
        // Если карта инициализирована, приближаем её к координатам кликнутой локации
        if(panZoomInstance && typeof loc.x !== 'undefined' && typeof loc.y !== 'undefined') {
            panZoomInstance.zoomToPoint(2.5, {x: loc.x, y: loc.y}); // Приближаем в 2.5 раза
        }
    });
    parentGroup.appendChild(group);
    // Если в дереве локаций есть дочерние элементы для текущей локации,
    // рекурсивно вызываем для них эту же функцию
    if (locationTree[loc.place]) {
        // Создаем специальную группу для дочерних элементов (деталей)
        const detailsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        detailsGroup.classList.add('details-group');
        // Устанавливаем уровень зума для группы деталей на 1 больше, чем у родителя
        if (loc.zoomLevel) {
            detailsGroup.classList.add(`zoom-level-${loc.zoomLevel + 1}`);
        }
        group.appendChild(detailsGroup);
        // Отрисовываем каждого "ребенка" внутри этой группы
        locationTree[loc.place].forEach(childLoc => renderLocation(childLoc, detailsGroup));
    }
}
    
    // Запускаем рекурсивную отрисовку, начиная с локаций верхнего уровня ('canvas')
    if (locationTree['canvas']) {
        locationTree['canvas'].forEach(loc => renderLocation(loc, locationsGroup));
    }

    // Добавляем все слои на SVG-холст
    svg.appendChild(regionsGroup);
    svg.appendChild(connectionsGroup);
    svg.appendChild(locationsGroup);

    // Инициализируем управление картой (перетаскивание и масштабирование), если это не было сделано ранее
    if (!panZoomInstance) {
        panZoomInstance = initPanAndZoom(MAP_WIDTH, MAP_HEIGHT);
    } else {
        // Если уже было, просто сбрасываем вид на начальный
        panZoomInstance.resetView();
    }
}
// ЗАМЕНИТЕ СТАРУЮ ВЕРСИЮ initPanAndZoom НА ЭТУ
let panZoomInstance = null; // Глобальная переменная для хранения экземпляра

function initPanAndZoom(width, height) {
    const svg = document.getElementById('mapCanvas');
    if (!svg) return null;

    let viewBox = { x: 0, y: 0, width: width, height: height };
    let currentZoom = 1;
    const MIN_ZOOM = 0.5;
    const MAX_ZOOM = 5;

    svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);

    let isPanning = false;
    let startPoint = { x: 0, y: 0 };
    
    function getPoint(event) {
        let point = new DOMPoint(event.clientX, event.clientY);
        return point.matrixTransform(svg.getScreenCTM().inverse());
    }

    function onPointerDown(event) {
        isPanning = true;
        startPoint = getPoint(event);
    }

    function onPointerMove(event) {
        if (!isPanning) return;
        event.preventDefault();
        let point = getPoint(event);
        viewBox.x -= point.x - startPoint.x;
        viewBox.y -= point.y - startPoint.y;
        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
    }

    function onPointerUp() {
        isPanning = false;
    }

    function onWheel(event) {
        event.preventDefault();
        let point = getPoint(event);
        let scale = event.deltaY < 0 ? 0.85 : 1.15; // 0.85 для приближения, 1.15 для отдаления
        let newZoom = currentZoom * scale;

        if (newZoom < MIN_ZOOM || newZoom > MAX_ZOOM) return;
        currentZoom = newZoom;

        viewBox.x = point.x - (point.x - viewBox.x) * scale;
        viewBox.y = point.y - (point.y - viewBox.y) * scale;
        viewBox.width *= scale;
        viewBox.height *= scale;
        
        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
        updateZoomLevelData(currentZoom);
    }

    function updateZoomLevelData(zoom) {
        let level = 1;
        if (zoom > 1.8) level = 2;
        if (zoom > 3.5) level = 3;
        svg.dataset.zoomLevel = level;
    }

    function zoomToPoint(targetZoom, point) {
        currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetZoom));
        
        viewBox.width = width / currentZoom;
        viewBox.height = height / currentZoom;
        viewBox.x = point.x - viewBox.width / 2;
        viewBox.y = point.y - viewBox.height / 2;

        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
        updateZoomLevelData(currentZoom);
    }
    
    function resetView() {
        viewBox = { x: 0, y: 0, width: width, height: height };
        currentZoom = 1;
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        updateZoomLevelData(currentZoom);
    }

    mapContainer.addEventListener('wheel', onWheel, { passive: false });
    mapContainer.addEventListener('pointerdown', onPointerDown);
    mapContainer.addEventListener('pointermove', onPointerMove);
    mapContainer.addEventListener('pointerup', onPointerUp);
    mapContainer.addEventListener('pointerleave', onPointerUp);

    zoomInBtn.onclick = () => onWheel({ deltaY: -1, clientX: svg.clientWidth / 2, clientY: svg.clientHeight / 2, preventDefault: () => {} });
    zoomOutBtn.onclick = () => onWheel({ deltaY: 1, clientX: svg.clientWidth / 2, clientY: svg.clientHeight / 2, preventDefault: () => {} });
    resetViewBtn.onclick = resetView;
    
    // Возвращаем объект с публичными методами
    return {
        zoomToPoint,
        resetView
    };
}
// НОВОЕ: Функция для показа подсказки на карте
function showLocationTooltip(event, loc) {
    const mapTooltip = document.getElementById('mapTooltip');
    const tooltipTitle = document.getElementById('tooltipTitle');
    const tooltipDescription = document.getElementById('tooltipDescription');
    const tooltipPlacesContainer = document.getElementById('tooltipPlaces');
    const tooltipPlacesList = document.getElementById('tooltipPlacesList');

    if (!mapTooltip || !tooltipTitle || !tooltipDescription || !tooltipPlacesList) return;

    // Заполняем основную информацию
    tooltipTitle.textContent = loc.place || 'Неизвестное место';
    tooltipDescription.textContent = loc.description || '';

    // Ищем дочерние известные локации для отображения в списке
const childLocations = (gameState.world.knownLocations || []).filter(knownLoc => knownLoc.parentLocation === loc.place);

    if (childLocations.length > 0) {
        tooltipPlacesList.innerHTML = ''; // Очищаем список
        childLocations.forEach(child => {
            const li = document.createElement('li');
            li.textContent = child.name;
            tooltipPlacesList.appendChild(li);
        });
        tooltipPlacesContainer.classList.remove('hidden');
    } else {
        tooltipPlacesContainer.classList.add('hidden');
    }

    // Позиционируем и показываем подсказку
    mapTooltip.classList.remove('hidden');
    const mapRect = mapContainer.getBoundingClientRect();
    
    // Позиционируем относительно курсора внутри контейнера карты
    let left = event.clientX - mapRect.left + 20;
    let top = event.clientY - mapRect.top + 20;

    // Проверяем, чтобы подсказка не выходила за пределы контейнера
    if (left + mapTooltip.offsetWidth > mapRect.width) {
        left = event.clientX - mapRect.left - mapTooltip.offsetWidth - 20;
    }
    if (top + mapTooltip.offsetHeight > mapRect.height) {
        top = event.clientY - mapRect.top - mapTooltip.offsetHeight - 20;
    }

    mapTooltip.style.left = `${left}px`;
    mapTooltip.style.top = `${top}px`;
}

// НОВОЕ: Функция для скрытия подсказки на карте
function hideLocationTooltip() {
    const mapTooltip = document.getElementById('mapTooltip');
    if (mapTooltip) {
        mapTooltip.classList.add('hidden');
    }
}
        // Updates the temperature comfort display based on LLM output in gameState.player.comfortInfo
        function updateTemperatureComfortDisplay() {
            const comfortInfo = gameState.player.comfortInfo;
            let comfortLevelPercentage;
            // Map effective temperature to a 0-100 comfort percentage for the slider
            const MIN_DISPLAY_TEMP = -20; // Absolute freezing for slider display
            const MAX_DISPLAY_TEMP = 40; // Absolute scorching for slider display
            if (comfortInfo.effectiveTemperature < MIN_DISPLAY_TEMP) {
                comfortLevelPercentage = 0;
            } else if (comfortInfo.effectiveTemperature > MAX_DISPLAY_TEMP) {
                comfortLevelPercentage = 100;
            } else {
                comfortLevelPercentage = ((comfortInfo.effectiveTemperature - MIN_DISPLAY_TEMP) / (MAX_DISPLAY_TEMP - MIN_DISPLAY_TEMP)) * 100;
            }
            comfortLevelPercentage = Math.max(0, Math.min(100, comfortLevelPercentage));
            currentComfortStatus.textContent = comfortInfo.statusName;
            comfortSlider.style.left = `${comfortLevelPercentage}%`;
            // Tooltip for comfort slider
            temperatureComfortContainer.onclick = (event) => {
                const currentTemp = gameState.world.currentLocation.indoors && gameState.world.indoorTemperature !== 'N/A' ? parseFloat(gameState.world.indoorTemperature.replace('°C', '').trim()) : parseFloat(gameState.world.weather.temperature.replace('°C', '').trim());
                const clothingResistance = gameState.player.equippedItems ? Object.values(gameState.player.equippedItems).reduce((sum, item) => sum + (item ? item.temperatureResistance || 0 : 0), 0) : 0;
                showTooltip(event, {
                    statusName: comfortInfo.statusName,
                    description: comfortInfo.description,
                    currentTemp: isNaN(currentTemp) ? 'N/A' : currentTemp,
                    clothingResistance: clothingResistance,
           
                    hasWarmSource: gameState.world.currentLocation.warmSource || false,
                    hotFoodBonus: gameState.player.temporaryWarmth || 0,
                    effectiveTemperature: comfortInfo.effectiveTemperature,
                    type: 'comfort_status'
                }, 'comfort_status');
            };
        }
        // Function to update and show property modal
        function updatePropertyDisplay() {
            const property = gameState.player.property;
            // Helper to render a list of property items
            const renderPropertyList = (listElement, items, type) => {
                listElement.innerHTML = '';
                if (items && items.length > 0) {
                    items.forEach(item => {
                        const li = document.createElement('li');
                        li.classList.add('property-item', 'cursor-pointer', 'hover:bg-gray-100', 'rounded-md');
                  
                        let iconClass = '';
                        if (type === 'house') iconClass = 'fas fa-house-user';
                        else if (type === 'plot') iconClass = 'fas fa-tree';
                        else if (type === 'field') iconClass = 'fas fa-seedling';
                        else if (type === 'barn') iconClass = 'fas fa-warehouse';
                        else if (type === 'livestock') iconClass = 'fas fa-cow';
                        else if (type === 'vehicle') iconClass = 'fas fa-truck-moving';
                        li.innerHTML = `<i class="${iconClass}"></i> <span>${item.name || 'Неизвестно'}</span>`;
                        li.addEventListener('click', (event) => showTooltip(event, item, type));
                        listElement.appendChild(li);
                    });
                } else {
                    listElement.innerHTML = '<li class="text-gray-500 italic text-sm">Ничего не приобретено.</li>';
                }
            };
            renderPropertyList(ownedHousesList, property.houses, 'house');
            renderPropertyList(ownedPlotsList, property.plots, 'plot');
            renderPropertyList(ownedFieldsList, property.fields, 'field');
            renderPropertyList(ownedBarnsList, property.barns, 'barn');
            renderPropertyList(ownedLivestockList, property.livestock, 'livestock');
            renderPropertyList(ownedVehiclesList, property.vehicles, 'vehicle');
        }
        function showPropertyModal() {
            propertyModal.classList.remove('hidden');
            updatePropertyDisplay(); // Refresh content when opening
        }
        function closePropertyModal() {
            propertyModal.classList.add('hidden');
            hideTooltip(); // Hide any active tooltip when closing modal
        }
        // Function to update and show character description modal
        function updateCharacterDescriptionDisplay() {
    characterDescriptionContent.innerHTML = `
        <p class="mb-2"><span class="font-semibold">Имя:</span> ${gameState.player.name}</p>
        <p class="mb-2"><span class="font-semibold">Раса:</span> ${capitalizeFirstLetter(gameState.player.race || 'человек')}</p>
        <p class="mb-2"><span class="font-semibold">Пол:</span> ${capitalizeFirstLetter(gameState.player.gender)}</p>
        <p class="mb-2"><span class="font-semibold">Возраст:</span> ${gameState.player.age} лет</p>
        <p class="mb-2"><span class="font-semibold">Внешность:</span> ${gameState.player.characterDescription}</p>
    `;
    characterDescriptionModal.classList.remove('hidden');
}
// Consolidated function to update all dynamic game information on the UI
function displayGameInfo() {
    updateStatus();
    // --- ИЗМЕНЕНИЕ ---
    // Заменили updateNPCDisplay() на updateSurroundingsDisplay()
    updateSurroundingsDisplay();
    // --- КОНЕЦ ИЗМЕНЕНИЯ ---
    updateRecordsDisplay();
    updateQuestsDisplay();
    updateCharactersDisplay();
    updateLocationsDisplay();
    updateCompanionsDisplay();
    updateTimeLocationDisplay();
    renderDynamicOptions();
    updateCombatDisplay();
    updateSlavaThoughtsDisplay();
    updateEventLogDisplay();
    updateTemperatureComfortDisplay();
    updatePropertyDisplay();
    updatePageBackground();
    updateGameContainerBackground();
    // Add the new "О персонаже" button to the UI if not already there
    const playerStatusDiv = document.querySelector('.bg-gray-50.rounded-md.p-3.border.border-gray-200');
    if (playerStatusDiv && !document.getElementById('showCharacterDescriptionButton')) {
        playerStatusDiv.parentNode.insertBefore(showCharacterDescriptionButton, playerStatusDiv.nextSibling);
    }
    // Handle game over state
    if (gameState.gamePhase === 'dead') {
        commandInput.disabled = true; // Disable input
        submitCommandBtn.disabled = true; // Disable submit button
        newGameButton.classList.remove('hidden'); // Show new game button
        // REMOVED: newCharacterButton logic is gone
        gameOverMessage.classList.remove('hidden'); // Show game over message
    } else {
        // Re-enable inputs if not dead
        commandInput.disabled = false;
        submitCommandBtn.disabled = false;
        gameOverMessage.classList.add('hidden'); // Hide game over message
    }
}
        
        // Updates time and location display
        function updateTimeLocationDisplay() {
            const location = gameState.world.currentLocation;
            const weather = gameState.world.weather;
            const indoors = location.indoors;
            const temperature = indoors ? gameState.world.indoorTemperature : weather.temperature;
            const displayTemp = temperature !== 'N/A' ? `${temperature}` : 'N/A';
            timeLocationDisplay.innerHTML = `
                <div class="flex items-center justify-between">
                    <span><i class="fas fa-calendar-alt"></i> ${gameState.world.currentDate} | <i class="fas fa-clock"></i> ${gameState.world.currentTime} | <i class="fas fa-sun"></i> ${capitalizeFirstLetter(gameState.world.season)}</span>
                    <span><i class="fas ${weather.icon}"></i> ${displayTemp} | ${weather.description}</span>
                </div>
                <div class="text-center mt-1">
                    <i class="fas fa-map-marker-alt"></i> ${formatLocation(location)} ${indoors ? '(В помещении)' : ''}
                </div>
            `;
        }
// НОВАЯ ФУНКЦИЯ: Обновление динамического фона СТРАНИЦЫ (сплошной цвет)
function updatePageBackground() {
    if (!gameState || !gameState.world || !gameState.world.currentTime) {
        document.body.style.backgroundColor = '#4a5568'; // Default dark blue-gray
        return;
    }

    const timeString = gameState.world.currentTime;
    const hour = parseInt(timeString.split(':')[0]);
    let bgColor = '#4a5568'; // Default (Night)

    if (hour >= 5 && hour < 8) {
        bgColor = '#4A6E8A'; // Рассвет
    } else if (hour >= 8 && hour < 17) {
        bgColor = '#63B3ED'; // День
    } else if (hour >= 17 && hour < 21) {
        bgColor = '#B86B77'; // Закат
    } else {
        bgColor = '#2C3E50'; // Ночь
    }
    document.body.style.backgroundColor = bgColor;
}

// НОВАЯ ФУНКЦИЯ: Обновление динамического фона ИГРОВОГО КОНТЕЙНЕРА (ОЧЕНЬ прозрачный)
function updateGameContainerBackground() {
            const gameContainer = document.getElementById('gameContainer');
            if (!gameContainer || !gameState || !gameState.world || !gameState.world.currentTime) return;
            const timeString = gameState.world.currentTime;
            const hour = parseInt(timeString.split(':')[0]);
            
            // Очень светлые, почти белые цвета с легким оттенком
            let bgColor = 'rgba(44, 62, 80, 0.1)'; // Ночь (очень легкий серо-синий)
            if (hour >= 5 && hour < 8) {
                bgColor = 'rgba(255, 235, 205, 0.3)'; // Рассвет (очень легкий оранжево-розовый)
            } else if (hour >= 8 && hour < 17) {
                bgColor = 'rgba(225, 245, 254, 0.4)'; // День (очень легкий небесно-голубой)
            } else if (hour >= 17 && hour < 21) {
                bgColor = 'rgba(255, 224, 178, 0.3)'; // Закат (очень легкий персиковый)
            }
            gameContainer.style.backgroundColor = bgColor;
        }
        
        // MODIFIED: Handles the decay of player's and companions' statuses (simplified for companions)
function processTimeBasedUpdates() {
const player = gameState.player;
const companions = gameState.player.companions;

// Player decay - ONLY IF NOT SLEEPING
if (!player.isSleeping) {
player.hunger = Math.min(100, player.hunger + 2); // Hunger increases (gets more hungry)
player.thirst = Math.min(100, player.thirst + 3); // Thirst increases (gets more thirsty)
player.stamina = Math.max(0, player.stamina - 1); // Stamina decreases
}
// player.cleanliness = Math.max(0, player.cleanliness - 1); // Cleanliness decreases (always)
// ИЗМЕНЕНИЕ: Снижение чистоты ~1% за 3 хода (1.5ч, если ход ~30 мин)
player.cleanliness = Math.max(0, player.cleanliness - 0.334);

// Remove expired statuses first for both player and companions
player.statuses = player.statuses.filter(s => {
if (s.duration !== Infinity && s.duration !== undefined) {
s.duration--; // Decrement duration

return s.duration > 0; // Keep if duration is still positive
}
return true; // Keep permanent statuses
});
// Apply debuffs/statuses for player based on needs
// Hunger statuses
if (player.hunger >= 80 && !player.statuses.some(s => s.name === 'Голодный' && s.type === 'basic_need')) {
player.statuses.push({name: 'Голодный', description: 'Ваш желудок урчит от голода. Это может влиять на вашу выносливость.', duration: Infinity, type: 'basic_need'});
displayMessage('Вы чувствуете сильный голод!');
} else if (player.hunger >= 100 && !player.statuses.some(s => s.name === 'Истощённый' && s.type === 'basic_need')) {
player.statuses.push({name: 'Истощённый', description: 'Вы истощены голодом, и ваше здоровье медленно убывает.', duration: Infinity, type: 'basic_need'});
player.health = Math.max(0, player.health - 2); // Lose health when starved
displayMessage('Вы голодаете и теряете здоровье!');
}
// Remove hunger statuses if hunger is below threshold
player.statuses = player.statuses.filter(s => {
if ((s.name === 'Голодный' || s.name === 'Истощённый') && player.hunger < 80 && s.type === 'basic_need') {
return false; // Remove if hunger is no longer high

}
return true;
});
// Thirst statuses
if (player.thirst >= 80 && !player.statuses.some(s => s.name === 'Жаждущий' && s.type === 'basic_need')) {
player.statuses.push({name: 'Жаждущий', description: 'Во рту пересохло. Это может влиять на вашу выносливость.', duration: Infinity, type: 'basic_need'});
displayMessage('Вы чувствуете сильную жажду!');
} else if (player.thirst >= 100 && !player.statuses.some(s => s.name === 'Обезвоженный' && s.type === 'basic_need')) {
player.statuses.push({name: 'Обезвоженный', description: 'Вы обезвожены, и ваше здоровье быстро убывает.', duration: Infinity, type: 'basic_need'});
player.health = Math.max(0, player.health - 5); // Lose health faster when dehydrated
displayMessage('Вы обезвожены и быстро теряете здоровье!');
}
// Remove thirst statuses if thirst is below threshold
player.statuses = player.statuses.filter(s => {
if ((s.name === 'Жаждущий' || s.name === 'Обезвоженный') && player.thirst < 80 && s.type === 'basic_need') {
return false; // Remove if thirst is no longer high

}
return true;
});
// Cleanliness statuses
if (player.cleanliness <= 30 && !player.statuses.some(s => s.name === 'Грязный' && s.type === 'hygiene')) {
player.statuses.push({name: 'Грязный', description: 'Вы чувствуете себя грязным. Пора бы помыться.', duration: Infinity, type: 'hygiene'});
displayMessage('Вы чувствуете себя грязным!');
} else if (player.cleanliness <= 10 && !player.statuses.some(s => s.name === 'Чесотка' && s.type === 'hygiene')) {
player.statuses.push({name: 'Чесотка', description: 'Вы заболели из-за недостатка гигиены. Ваше здоровье медленно убывает.', duration: Infinity, type: 'hygiene'});
player.health = Math.max(0, player.health - 1); // Small health penalty
displayMessage('Вы начинаете чувствовать себя плохо из-за грязи...');
}
// Remove cleanliness statuses if cleanliness is restored
player.statuses = player.statuses.filter(s => {
if ((s.name === 'Грязный' || s.name === 'Чесотка') && player.cleanliness > 30 && s.type === 'hygiene') {
return false; // Remove if clean enough

}
return true;
});
// Companion decay and statuses - ONLY IF NOT SLEEPING (companions also rest)
companions.forEach(companion => {
if (!player.isSleeping) { // Companions also don't get hungry/thirsty during player's sleep
if (companion.hunger !== undefined) companion.hunger = Math.min(100, companion.hunger + 1);
if (companion.thirst !== undefined) companion.thirst = Math.min(100, companion.thirst + 1);
}
// REMOVED: Cleanliness decay for companions is gone.

// Companion hunger status
if (companion.hunger >= 70 && !companion.status.includes('hungry')) {
companion.status.push('hungry');
} else if (companion.hunger < 70 && companion.status.includes('hungry')) {
companion.status = companion.status.filter(s => s !== 'hungry');
}

// Companion thirst status
if (companion.thirst >= 70 && !companion.status.includes('thirsty')) {
companion.status.push('thirsty');
} else if (companion.thirst < 70 && companion.status.includes('thirsty')) {
companion.status = companion.status.filter(s => s !== 'thirsty');
}
// Sickness from other sources can still be added by the LLM, but no longer from dirt.
});
}
        
        // Advances global events in the game world, potentially affecting narrative and weather
        
// Generic function to handle array changes (add, remove, update)
function handleArrayChanges(targetArray, changesArray, keyField) {
if (!changesArray) return;
console.log(`[handleArrayChanges] Processing changes for: ${keyField}`, changesArray);
changesArray.forEach(change => {
const itemToChange = change.item || change.npc || change.location || change.lore || change.status || change.skill || change.companion || change.property;
const currentKey = change.name || (itemToChange && itemToChange[keyField]); // Use change.name for remove action or itemToChange's keyField
const existingIndex = targetArray.findIndex(elem => elem[keyField] === currentKey);

if (change.action === 'add') {
if (existingIndex === -1 && itemToChange) {
targetArray.push(itemToChange);

console.log(`[handleArrayChanges] Added to ${keyField}:`, itemToChange);
} else if (existingIndex !== -1 && itemToChange) {
// Special handling for quantity in inventory
if (keyField === 'id' && itemToChange.quantity !== undefined && targetArray[existingIndex].quantity !== undefined) {
targetArray[existingIndex].quantity += (typeof itemToChange.quantity === 'number' ? itemToChange.quantity : parseInt(itemToChange.quantity) || 0);
} else {
Object.assign(targetArray[existingIndex], itemToChange); // Merge properties for existing items
}
console.log(`[handleArrayChanges] Updated (add existing) in ${keyField}:`, targetArray[existingIndex]);
}
} else if (change.action === 'remove') {
if (existingIndex !== -1) {
// Handle quantity for inventory
if (keyField === 'id' && itemToChange && itemToChange.quantity !== undefined && targetArray[existingIndex].quantity !== undefined) {
targetArray[existingIndex].quantity -= (typeof itemToChange.quantity === 'number' ? itemToChange.quantity : parseInt(itemToChange.quantity) || 1);
if (targetArray[existingIndex].quantity <= 0) {
targetArray.splice(existingIndex, 1);
console.log(`[handleArrayChanges] Removed from ${keyField} (quantity zero):`, currentKey);
} else {
console.log(`[handleArrayChanges] Decremented quantity for ${keyField}:`, targetArray[existingIndex]);
}
} else {
targetArray.splice(existingIndex, 1);
console.log(`[handleArrayChanges] Removed from ${keyField}:`, currentKey);
}
} else {
console.warn(`[handleArrayChanges] Attempted to remove non-existent item from ${keyField}:`, currentKey);
}
} else if (change.action === 'update') {
if (existingIndex !== -1 && itemToChange) {
Object.assign(targetArray[existingIndex], itemToChange); // Specific check for skill level cap
if (keyField === 'name' && change.skill && change.skill.level !== undefined && targetArray[existingIndex].maxLevel !== undefined) {
targetArray[existingIndex].level = Math.min(change.skill.level, targetArray[existingIndex].maxLevel); // Ensure level doesn't exceed maxLevel
}
} else {
console.warn(`[handleArrayChanges] Attempted to update non-existent item in ${keyField}:`, currentKey);
}
}
});
console.log(`[handleArrayChanges] ${keyField} after changes:`, targetArray);
}
// =========================================================================
// НОВЫЙ БЛОК: ФУНКЦИИ ДЛЯ УПРАВЛЕНИЯ ЖУРНАЛАМИ (ЗАМЕНА ЗАПИСНОЙ КНИЖКИ)
// =========================================================================

// 1. ЖУРНАЛ ЗАПИСЕЙ (RECORDS)
// -------------------------------------------------------------------------
function updateRecordsDisplay() {
    recordsContent.innerHTML = '';
    const events = gameState.narrative.majorEvents || [];
    if (events.length === 0) {
        recordsContent.innerHTML = '<p class="italic text-gray-500">Важных событий еще не произошло.</p>';
        return;
    }
    // Сортируем события от новых к старым
    [...events].reverse().forEach(entry => {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'journal-entry';
        entryDiv.innerHTML = `
            <h4>${entry.title || 'Безымянное событие'}</h4>
            <p>${entry.description || 'Нет описания.'}</p>
            <div class="meta">
                <span>${entry.timestamp || ''}</span>
                ${entry.source ? `<span> | Источник: ${entry.source}</span>` : ''}
            </div>
        `;
        recordsContent.appendChild(entryDiv);
    });
}

function showRecordsModal() {
    updateRecordsDisplay();
    recordsModal.classList.remove('hidden');
}

function closeRecordsModal() {
    recordsModal.classList.add('hidden');
}

// 2. ЖУРНАЛ КВЕСТОВ (QUESTS)
// -------------------------------------------------------------------------
function updateQuestsDisplay() {
    const quests = gameState.player.quests;

    const renderQuestList = (tabId, questList, type) => {
        const container = document.getElementById(tabId);
        container.innerHTML = '';
        if (!questList || questList.length === 0) {
            container.innerHTML = `<p class="italic text-gray-500">Нет заданий в этой категории.</p>`;
            return;
        }
        questList.forEach(quest => {
            const entryDiv = document.createElement('div');
            entryDiv.className = 'journal-entry';
            
            let objectivesHtml = '';
            if (quest.objectives && quest.objectives.length > 0) {
                objectivesHtml = '<ul>' + quest.objectives.map(obj => `<li class="list-disc ml-5">- ${obj}</li>`).join('') + '</ul>';
            }

            entryDiv.innerHTML = `
                <h4>${quest.title || 'Безымянное задание'}</h4>
                <p>${quest.description || 'Нет описания.'}</p>
                ${objectivesHtml}
                <div class="meta">
                    ${quest.giver ? `<span>Выдал: ${quest.giver}</span>` : ''}
                    ${quest.location ? `<span class="ml-2"> | Место: ${quest.location}</span>` : ''}
                    ${quest.reward && type !== 'completed' ? `<span class="ml-2"> | Награда: ${quest.reward}</span>` : ''}
                </div>
            `;
            container.appendChild(entryDiv);
        });
    };

    renderQuestList('personalQuestsTab', quests.personal, 'personal');
    renderQuestList('globalQuestsTab', quests.global, 'global');
    renderQuestList('completedQuestsTab', quests.completed, 'completed');
}


function showQuestsModal() {
    updateQuestsDisplay();
    // Активируем первую вкладку при открытии
    questTabButtons.forEach(b => b.classList.remove('active'));
    questTabContents.forEach(c => c.classList.add('hidden'));
    questTabButtons[0].classList.add('active');
    questTabContents[0].classList.remove('hidden');
    questsModal.classList.remove('hidden');
}

function closeQuestsModal() {
    questsModal.classList.add('hidden');
}

// 3. ЖУРНАЛ ПЕРСОНАЖЕЙ (CHARACTERS)
// -------------------------------------------------------------------------
function updateCharactersDisplay() {
    charactersContent.innerHTML = '';
    const npcs = gameState.world.npcs || [];
    if (npcs.length === 0) {
        charactersContent.innerHTML = '<p class="italic text-gray-500">Вы еще никого не встретили.</p>';
        return;
    }
     [...npcs].reverse().forEach(npc => {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'journal-entry';
        entryDiv.innerHTML = `
            <h4>${npc.name || 'Безымянный'} <span class="text-lg font-normal">(${npc.race || 'неизвестная раса'})</span></h4>
            <p>${npc.description || 'Нет описания.'}</p>
             <div class="meta">
                ${npc.lastMetAt ? `<span>Последняя встреча: ${npc.lastMetAt.location} (${npc.lastMetAt.date})</span>` : ''}
            </div>
        `;
        charactersContent.appendChild(entryDiv);
    });
}

function showCharactersModal() {
    updateCharactersDisplay();
    charactersModal.classList.remove('hidden');
}

function closeCharactersModal() {
    charactersModal.classList.add('hidden');
}


// 4. ЖУРНАЛ ЛОКАЦИЙ (LOCATIONS)
// -------------------------------------------------------------------------
function updateLocationsDisplay() {
    locationsContent.innerHTML = '';
    const locations = gameState.world.knownLocations || [];
    if (locations.length === 0) {
        locationsContent.innerHTML = '<p class="italic text-gray-500">Вы еще не открыли ни одного места.</p>';
        return;
    }
    [...locations].reverse().forEach(loc => {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'journal-entry';
        // Используем name, с откатом на place для старых сохранений
        const locName = loc.name || loc.place || 'Безымянное место';
        entryDiv.innerHTML = `
            <h4>${locName}</h4>
            <p>${loc.description || 'Нет описания.'}</p>
        `;
        locationsContent.appendChild(entryDiv);
    });
}

function showLocationsModal() {
    updateLocationsDisplay();
    locationsModal.classList.remove('hidden');
}

function closeLocationsModal() {
    locationsModal.classList.add('hidden');
}
        // Handles changes to player's property
        function handlePropertyChanges(propertyChanges) {
            if (!propertyChanges) return;
            console.log(`[handlePropertyChanges] Processing property changes:`, propertyChanges);
            for (const category in propertyChanges) {
                if (gameState.player.property.hasOwnProperty(category)) {
                    handleArrayChanges(gameState.player.property[category], propertyChanges[category], 'id'); // Assuming each property item has an 'id'
                } else {
                    console.warn(`[handlePropertyChanges] Неизвестная категория имущества: ${category}`);
                }
            }
        }
// Applies updates from LLM response to the gameState
function applyGameUpdates(updates) {
    console.log('[applyGameUpdates] Applying updates:', updates);

    // 1. ОБНОВЛЕНИЕ ПОВЕСТВОВАНИЯ
    if (updates.narrative && typeof updates.narrative === 'object') {
        if (typeof updates.narrative.text === 'string') {
            displayMessage(updates.narrative.text);
            gameState.narrative.currentScene.text = updates.narrative.text;
            gameState.narrative.history.push(updates.narrative.text);
        }
        if (typeof updates.narrative.id === 'string') gameState.narrative.currentScene.id = updates.narrative.id;
        if (Array.isArray(updates.narrative.options)) gameState.narrative.currentScene.options = updates.narrative.options;
        if (typeof updates.narrative.slavaThoughts === 'string') gameState.narrative.slavaThoughts = updates.narrative.slavaThoughts;
        if (typeof updates.narrative.sceneDescription === 'string') gameState.narrative.sceneDescription = updates.narrative.sceneDescription;
        if (Array.isArray(updates.narrative.recentKeywords)) gameState.narrative.recentKeywords = updates.narrative.recentKeywords;
        if (Array.isArray(updates.narrative.dialogueKeywords)) gameState.narrative.dialogueKeywords = updates.narrative.dialogueKeywords;
    }

    // =======================================================
    // === СОХРАНЕНИЕ СКРЫТОГО ЛОГА ПЕРСОНАЖЕЙ ===
    // =======================================================
    if (updates.characterEventLogChanges && Array.isArray(updates.characterEventLogChanges)) {
        if (!gameState.world.characterEventLog) gameState.world.characterEventLog = [];
        updates.characterEventLogChanges.forEach(change => {
            if (change.action === 'add' && change.entry) {
                const newEntry = change.entry;
                // Добавляем метаданные
                newEntry.id = 'log_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                newEntry.timestamp = `${gameState.world.currentDate}, ${gameState.world.currentTime}`;
                newEntry.turn = gameState.world.turnCounter;
                gameState.world.characterEventLog.push(newEntry);
                console.log(`[CharLog] New entry added: ${newEntry.text}`);
            }
        });
        // Ограничиваем размер лога (например, 200 последних записей)
        if (gameState.world.characterEventLog.length > 200) {
            gameState.world.characterEventLog = gameState.world.characterEventLog.slice(-200);
        }
    }

    // 2. ОБНОВЛЕНИЕ NPC
    if (updates.worldUpdate && updates.worldUpdate.npcsChanges && Array.isArray(updates.worldUpdate.npcsChanges)) {
        updates.worldUpdate.npcsChanges.forEach(change => {
            const item = change.item;
            const idx = gameState.world.npcs.findIndex(n => n.id === item.id);

            if (change.action === 'add') {
                if (idx === -1) {
                    gameState.world.npcs.push(item);
                } else {
                    Object.assign(gameState.world.npcs[idx], item);
                }
            } else if (change.action === 'update') {
                if (idx !== -1) {
                    Object.assign(gameState.world.npcs[idx], item);
                }
            } else if (change.action === 'remove') {
                if (idx !== -1) gameState.world.npcs.splice(idx, 1);
            }
        });
    }

    // 3. ОБРАБОТКА ОСТАЛЬНОГО МИРА
    if (updates.worldUpdate && typeof updates.worldUpdate === 'object') {
        const worldUpdate = updates.worldUpdate;

        if (worldUpdate.currentLocation) {
            if (!worldUpdate.currentLocation.name && worldUpdate.currentLocation.place) {
                worldUpdate.currentLocation.name = worldUpdate.currentLocation.place;
            }
            if (!worldUpdate.currentLocation.id) {
                worldUpdate.currentLocation.id = 'loc_' + (worldUpdate.currentLocation.name || 'unknown').toLowerCase().replace(/\s/g, '_');
            }
            Object.assign(gameState.world.currentLocation, worldUpdate.currentLocation);
        }

        if (typeof worldUpdate.currentDate === 'string') gameState.world.currentDate = worldUpdate.currentDate;
        if (typeof worldUpdate.currentTime === 'string') gameState.world.currentTime = worldUpdate.currentTime;
        if (typeof worldUpdate.season === 'string') gameState.world.season = worldUpdate.season;
        if (worldUpdate.weather) gameState.world.weather = worldUpdate.weather;
        if (typeof worldUpdate.indoorTemperature === 'string') gameState.world.indoorTemperature = worldUpdate.indoorTemperature;
        if (typeof worldUpdate.inCombat === 'boolean') gameState.world.inCombat = worldUpdate.inCombat;
        
        // Обновление состояния мира (политика)
        if (worldUpdate.worldState) {
            if (!gameState.world.worldState) gameState.world.worldState = {};
            Object.assign(gameState.world.worldState, worldUpdate.worldState);
        }

        // НОВОЕ: Обновление Глобального Сюжета
        if (worldUpdate.globalPlotUpdate) {
            if (!gameState.world.globalPlot) gameState.world.globalPlot = {};
            // Если ИИ решил обновить сюжет, мы записываем новые данные
            Object.assign(gameState.world.globalPlot, worldUpdate.globalPlotUpdate);
            // Если сюжет перешел на новую стадию, выводим специальное сообщение
            if (worldUpdate.globalPlotUpdate.currentStage && worldUpdate.globalPlotUpdate.currentStage > (gameState.world.globalPlot.currentStage || 0)) {
                logInterTurnAction(`Глобальный сюжет "${gameState.world.globalPlot.title}" продвинулся до этапа ${worldUpdate.globalPlotUpdate.currentStage}!`);
            }
        }

        if (worldUpdate.combat) Object.assign(gameState.world.combat, worldUpdate.combat);
        
        handleArrayChanges(gameState.world.knownLocations, worldUpdate.locationChanges, 'id');

        if (worldUpdate._globalLore) gameState.world._globalLore = deepMerge(gameState.world._globalLore, worldUpdate._globalLore);
    }

    // 4. ЖУРНАЛЫ И КВЕСТЫ
    if (updates.majorEventsChanges) handleArrayChanges(gameState.narrative.majorEvents, updates.majorEventsChanges, 'id');

    if (updates.questsChanges && Array.isArray(updates.questsChanges)) {
        updates.questsChanges.forEach(change => {
            const quest = change.quest;
            const fromCategory = change.from;
            const toCategory = change.to;

            if (fromCategory && gameState.player.quests[fromCategory]) {
                const index = gameState.player.quests[fromCategory].findIndex(q => q.id === quest.id);
                if (index > -1) gameState.player.quests[fromCategory].splice(index, 1);
            }

            if (toCategory && gameState.player.quests[toCategory]) {
                const existingIndex = gameState.player.quests[toCategory].findIndex(q => q.id === quest.id);
                if (existingIndex > -1) Object.assign(gameState.player.quests[toCategory][existingIndex], quest);
                else gameState.player.quests[toCategory].push(quest);
            }
        });
    }

    // 5. ОБНОВЛЕНИЕ ИГРОКА
    if (updates.playerUpdate && typeof updates.playerUpdate === 'object') {
        const playerUpdate = updates.playerUpdate;

        if (typeof playerUpdate.health === 'number') gameState.player.health = Math.min(100, Math.max(0, playerUpdate.health));
        if (typeof playerUpdate.stamina === 'number') gameState.player.stamina = Math.min(100, Math.max(0, playerUpdate.stamina));
        if (typeof playerUpdate.hunger === 'number') gameState.player.hunger = Math.min(100, Math.max(0, playerUpdate.hunger));
        if (typeof playerUpdate.thirst === 'number') gameState.player.thirst = Math.min(100, Math.max(0, playerUpdate.thirst));
        if (typeof playerUpdate.cleanliness === 'number') gameState.player.cleanliness = Math.min(100, Math.max(0, playerUpdate.cleanliness));
        if (typeof playerUpdate.age === 'number') gameState.player.age = playerUpdate.age;
        if (typeof playerUpdate.characterDescription === 'string') gameState.player.characterDescription = playerUpdate.characterDescription;
        
        if (typeof playerUpdate.citizenship === 'string') gameState.player.citizenship = playerUpdate.citizenship;
        
        if (playerUpdate.playerProfile) {
            if (!gameState.player.playerProfile) gameState.player.playerProfile = {};
            Object.assign(gameState.player.playerProfile, playerUpdate.playerProfile);
        }

        if (playerUpdate.money) {
            const oldMoney = { ...gameState.player.money };
            if (typeof playerUpdate.money.copper === 'number') gameState.player.money.copper = playerUpdate.money.copper;
            if (typeof playerUpdate.money.silver === 'number') gameState.player.money.silver = playerUpdate.money.silver;
            if (typeof playerUpdate.money.gold === 'number') gameState.player.money.gold = playerUpdate.money.gold;

            const newMoney = gameState.player.money;
            const reason = "Транзакция от ИИ (Венди)";
            if (newMoney.copper !== oldMoney.copper) logMoneyTransaction(newMoney.copper - oldMoney.copper, 'copper', reason);
            if (newMoney.silver !== oldMoney.silver) logMoneyTransaction(newMoney.silver - oldMoney.silver, 'silver', reason);
            if (newMoney.gold !== oldMoney.gold) logMoneyTransaction(newMoney.gold - oldMoney.gold, 'gold', reason);
        }

        if (typeof playerUpdate.xp === 'number') {
            gameState.player.xp = playerUpdate.xp;
            while (gameState.player.xp >= getXpForNextLevel(gameState.player.level)) {
                gameState.player.xp -= getXpForNextLevel(gameState.player.level);
                gameState.player.level++;
                gameState.player.skillPoints++;
                displayMessage(`Поздравляем! Вы достигли ${gameState.player.level} уровня! Вы получили 1 очко навыков.`);
            }
        }

        if (typeof playerUpdate.temporaryWarmth === 'number') gameState.player.temporaryWarmth = playerUpdate.temporaryWarmth;
        if (typeof playerUpdate.isSleeping === 'boolean') gameState.player.isSleeping = playerUpdate.isSleeping;

        if (playerUpdate.comfortInfo) {
            Object.assign(gameState.player.comfortInfo, playerUpdate.comfortInfo);
            if (Array.isArray(playerUpdate.comfortInfo.appliedStatuses)) {
                gameState.player.statuses = gameState.player.statuses.filter(s =>
                    s.type !== 'temperature_effect' ||
                    playerUpdate.comfortInfo.appliedStatuses.some(as => as.name === s.name)
                );
                playerUpdate.comfortInfo.appliedStatuses.forEach(statusData => {
                    if (!gameState.player.statuses.some(s => s.name === statusData.name)) {
                        gameState.player.statuses.push({
                            name: statusData.name,
                            duration: statusData.duration || Infinity,
                            description: statusData.description || '',
                            type: statusData.type || 'temperature_effect'
                        });
                        displayMessage(`Вы получили статус: ${statusData.name}.`);
                    }
                });
            }
        }

        handleArrayChanges(gameState.player.inventory, playerUpdate.inventoryChanges, 'id');
        handleArrayChanges(gameState.player.statuses, playerUpdate.statusChanges, 'name');
        handleArrayChanges(gameState.player.skills, playerUpdate.skillChanges, 'name');
        handleArrayChanges(gameState.player.companions, playerUpdate.companionsChanges, 'id');

        gameState.player.companions.forEach(companion => {
            if (typeof companion.health === 'number') companion.health = Math.min(100, Math.max(0, companion.health));
            if (typeof companion.hunger === 'number') companion.hunger = Math.min(100, Math.max(0, companion.hunger));
            if (typeof companion.thirst === 'number') companion.thirst = Math.min(100, Math.max(0, companion.thirst));
        });

        handlePropertyChanges(playerUpdate.propertyChanges);

        if (Array.isArray(playerUpdate.equippedItemChanges)) {
            playerUpdate.equippedItemChanges.forEach(change => {
                if (change.action === 'equip' && change.item) {
                    const itemInInventory = gameState.player.inventory.find(invItem => invItem.id === change.item.id);
                    if (itemInInventory) equipItem(itemInInventory);
                } else if (change.action === 'unequip' && change.slot) {
                    unequipItem(change.slot);
                }
            });
        }
    }

    if (Array.isArray(updates.eventLogChanges)) {
        updates.eventLogChanges.forEach(change => {
            if (change.action === 'add' && typeof change.entry === 'string') {
                gameState.narrative.eventLog.push(change.entry);
            }
        });
    }

    if (typeof updates.gamePhase === 'string') gameState.gamePhase = updates.gamePhase;
}
        
        // Fetches random starter skills from LLM for character creation
        async function fetchStarterSkills() {
            console.log('[fetchStarterSkills] Fetching starter skills...');
            skillOptionsDiv.innerHTML = '<p class="text-gray-500 italic">Загрузка навыков...</p>';
            createCharButton.disabled = true; // Disable button while loading skills
            const prompt = `
            Сгенерируй список из 3 случайных, но релевантных стартовых навыков для текстовой RPG игры.
            Для каждого навыка укажи:
            - name (строка): Название навыка (например, "Выживание", "Торговля", "Базовое владение мечом" или любые другие навыки которые можно считать стартовыми, оригинальность приветствуется).
            - description (строка): Краткое описание навыка.
            - level (число): Начальный уровень (всегда 1).
            - upgradable (булево): Может ли этот навык быть улучшен позже (true/false).
            - maxLevel (число): Максимальный уровень навыка.
            Для "базовых" навыков (Выживание, Торговля, Владение мечом) - 12, для "магических" (Магия Огня, Магия Природы) или "сложных" (Алхимия, Видение Истины) - 7.
            Верни ответ в формате JSON.
            `;
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
const apiUrl = '/api/chat';
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                 
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
         
                                name: { type: "STRING" },
                                description: { type: "STRING" },
                                level: { type: "NUMBER" },
 
                                upgradable: { type: "BOOLEAN" },
                                maxLevel: { type: "NUMBER" } // Added maxLevel
                          
                            },
                            required: ["name", "description", "level", "upgradable", "maxLevel"] // Required
                        }
                    }
                }
   
            };
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    let responseText = result.candidates[0].content.parts[0].text;
                    let parsedSkills;
                    try {
                        parsedSkills = JSON.parse(responseText);
                        console.log('[fetchStarterSkills] Skills fetched successfully:', parsedSkills);
                    } catch (parseError) {
                         if (responseText.startsWith('```json')) {
                            responseText = responseText.substring(7).trim();
                         }
                        if (responseText.endsWith('```')) {
                            responseText = responseText.substring(0, responseText.length - 3).trim();
                        }
                        try {
                             parsedSkills = JSON.parse(responseText);
                             console.log('[fetchStarterSkills] Skills parsed after cleanup:', parsedSkills);
                        } catch (finalParseError) {
                            console.error("Ошибка парсинга JSON для навыков:", finalParseError, "Оригинальный текст:", responseText);
                            showMessageModal("Ошибка", "Не удалось загрузить стартовые навыки. Пожалуйста, перезагрузите страницу.");
                            return;
                        }
                    }
                    if (Array.isArray(parsedSkills) && parsedSkills.length === 3) { // Ensure exactly 3 skills are returned
                        skillOptionsDiv.innerHTML = ''; // Clear loading message
                        parsedSkills.forEach(skill => {
                            const skillDiv = document.createElement('div');
                            skillDiv.classList.add('flex', 'items-center', 'gap-2', 'p-2', 'bg-gray-100', 'rounded-md', 'cursor-pointer', 'hover:bg-gray-200');
     
                            skillDiv.innerHTML = `
                                <input type="radio" name="startSkill" id="skill_${skill.name.replace(/\s/g, '_')}" value="${skill.name}" class="form-radio text-blue-600">
                                <label for="skill_${skill.name.replace(/\s/g, '_')}" class="text-sm">${skill.name} (${skill.description})</label>
                            `;
                            skillDiv.querySelector('input').addEventListener('change', (event) => {
                                const selectedSkillName = event.target.value;
      
                                const selectedSkill = parsedSkills.find(s => s.name === selectedSkillName);
                                gameState.player.skills = [selectedSkill]; // Set the selected skill
                                createCharButton.disabled = charNameInput.value.trim() === '' || !selectedSkill; // Re-check button state
                            });
                            skillOptionsDiv.appendChild(skillDiv);
                        });
                        // Initial check for create button state after skills load
                        createCharButton.disabled = charNameInput.value.trim() === '' || (gameState.player.skills && gameState.player.skills.length === 0);
                    } else {
                        showMessageModal("Ошибка", "Не удалось получить список навыков от Венди. Попробуйте еще раз.");
                        skillOptionsDiv.innerHTML = '<p class="text-red-500 italic">Не удалось загрузить навыки.</p>';
                    }
                } else {
                    showMessageModal("Ошибка", "Пустой ответ при загрузке навыков. Попробуйте еще раз.");
                    skillOptionsDiv.innerHTML = '<p class="text-red-500 italic">Не удалось загрузить навыки.</p>';
                }
            } catch (error) {
                console.error("Ошибка связи с LLM (навыки):", error);
                showMessageModal("Ошибка", "Произошла ошибка связи при загрузке навыков. Пожалуйста, попробуйте еще раз.");
                skillOptionsDiv.innerHTML = '<p class="text-red-500 italic">Ошибка загрузки навыков из-за проблем с сетью.</p>';
            }
        }
        
        // Function to show the character creation modal
        async function showCharacterCreationModal() {
            console.log('[showCharacterCreationModal] Showing character creation modal.');
            charCreationModal.classList.remove('hidden');
            charNameInput.value = '';
            charGenderSelect.value = 'мужской';
            gameState.player.skills = []; // Clear any previously selected skills
            createCharButton.disabled = true; // Disable until name and skill are selected
            await fetchStarterSkills(); // Fetch new random starter skills
        }
// ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ: Выбирает 5 последних + 5 релевантных из переданного списка
// ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ: Выбирает 15 последних + 15 релевантных из переданного списка
// ЗАМЕНИТЬ СТАРУЮ ФУНКЦИЮ selectMemories5Plus5 НА ЭТУ
function selectMemoriesExpanded(sourceArray, keywords) {
    if (!sourceArray || sourceArray.length === 0) return [];

    // 1. Хронологические (15 последних)
    // Увеличиваем лимит, чтобы NPC помнил недавние события лучше
    const chronologicalCount = 15;
    const chronological = sourceArray.slice(-chronologicalCount);
    
    // Запоминаем ID, чтобы не дублировать
    const addedIds = new Set(chronological.map(m => m.id));

    // 2. Релевантные (15 штук по ключевым словам)
    const relevantCount = 15;
    const relevant = [];

    if (keywords && keywords.length > 0) {
        // Идем с конца (от новых к старым), чтобы найти самые свежие релевантные события
        for (let i = sourceArray.length - 1; i >= 0; i--) {
            const memory = sourceArray[i];
            
            // Если уже взяли в хронологические - пропускаем
            if (addedIds.has(memory.id)) continue;

            let matchFound = false;
            // Проверка по тегам памяти
            if (memory.keywords && Array.isArray(memory.keywords)) {
                if (memory.keywords.some(k => keywords.some(ck => k.toLowerCase().includes(ck.toLowerCase())))) {
                    matchFound = true;
                }
            }
            // Проверка по тексту
            if (!matchFound && memory.text) {
                if (keywords.some(ck => memory.text.toLowerCase().includes(ck.toLowerCase()))) {
                    matchFound = true;
                }
            }

            if (matchFound) {
                relevant.push(memory);
                if (relevant.length >= relevantCount) break;
            }
        }
    }

    // Возвращаем объединенный список: сначала старые релевантные, потом свежие хронологические.
    // Сортируем по номеру хода (turn), чтобы восстановить правильную последовательность событий.
    const combined = [...relevant, ...chronological];
    return combined.sort((a, b) => (a.turn || 0) - (b.turn || 0));
}

// ОСНОВНАЯ ФУНКЦИЯ ПАМЯТИ NPC
// ЗАМЕНИТЬ СТАРУЮ ФУНКЦИЮ getNPCFullMemoryPacket НА ЭТУ
/**
 * Формирует расширенный пакет памяти для NPC:
 * - До 30 записей взаимодействий (где он участник)
 * - До 30 записей наблюдений (где он свидетель/слухи)
 */
function getNPCFullMemoryPacket(npcId, globalMemories, currentKeywords) {
    if (!globalMemories || globalMemories.length === 0) return [];

    // Шаг 1: Разделяем все воспоминания этого NPC на две категории
    const interactions = []; // Где он участвовал лично
    const observations = []; // Где он смотрел или слышал

    globalMemories.forEach(memory => {
        if (memory.participants && memory.participants.includes(npcId)) {
            interactions.push(memory);
        } else if (memory.witnesses && memory.witnesses.includes(npcId)) {
            observations.push(memory);
        }
    });

    // Шаг 2: Применяем расширенную логику "15+15" к каждой категории
    const selectedInteractions = selectMemoriesExpanded(interactions, currentKeywords);
    const selectedObservations = selectMemoriesExpanded(observations, currentKeywords);

    // Шаг 3: Объединяем и помечаем тип для ясности (для LLM)
    // Добавляем поле _contextType, чтобы LLM различала личный опыт и слухи
    const finalMemory = [
        ...selectedInteractions.map(m => ({ 
            ...m, 
            _contextType: 'INTERACTION (Личное участие)',
            _note: `Источник знания: ${m.source || 'Неизвестно'}` 
        })),
        ...selectedObservations.map(m => ({ 
            ...m, 
            _contextType: 'OBSERVATION (Наблюдение/Слух)',
            _note: `Источник знания: ${m.source || 'Наблюдение'}`
        }))
    ];

    // Финальная сортировка всего пакета по времени
    return finalMemory.sort((a, b) => (a.turn || 0) - (b.turn || 0));
}
        
        // NEW: Function to build a lean version of the game state for the LLM prompt
// ЗАМЕНИТЬ СТАРУЮ ФУНКЦИЮ НА ЭТУ
function buildLeanGameStateForLLM() {
    const GLOBAL_ITEMS_COUNT = 10;
    const GLOBAL_RELEVANT_COUNT = 10;
    const EVENTS_CHRONO_COUNT = 50;
    const EVENTS_RELEVANT_COUNT = 50;

    const leanState = JSON.parse(JSON.stringify(gameState));
    
    const globalKeywords = leanState.narrative.recentKeywords || [];
    const dialogueKeywords = leanState.narrative.dialogueKeywords || [];
    
    // Фильтрация NPC
    leanState.world.npcs = getRelevantItems(
        gameState.world.npcs,
        globalKeywords,
        ['name', 'description', 'race'],
        'id',
        GLOBAL_ITEMS_COUNT,
        true,
        GLOBAL_RELEVANT_COUNT
    );

    if (leanState.world.npcs.length > 0) {
        leanState.world.npcs.forEach(npc => {
            if (!npc.npcMemory) {
                npc.npcMemory = { knowsPlayerName: null, activeMemory: [] };
            }
            const originalNpc = gameState.world.npcs.find(n => n.id === npc.id);
            if (originalNpc) {
                if (originalNpc.npcMemory) {
                    npc.npcMemory.knowsPlayerName = originalNpc.npcMemory.knowsPlayerName;
                }
                if (originalNpc.personalityTraits) {
                    npc.personalityTraits = originalNpc.personalityTraits;
                }
            }
            npc.npcMemory.activeMemory = getNPCFullMemoryPacket(
                npc.id,
                gameState.world.characterEventLog,
                dialogueKeywords
            );
            if (npc.npcMemory.contextualFacts) delete npc.npcMemory.contextualFacts;
        });
    }

    // Фильтрация локаций
    leanState.world.knownLocations = getRelevantItems(
        gameState.world.knownLocations,
        globalKeywords,
        ['name', 'place', 'description'],
        'id',
        GLOBAL_ITEMS_COUNT,
        true,
        GLOBAL_RELEVANT_COUNT
    );

    // Квесты и события
    leanState.player.quests.completed = getRelevantItems(
        gameState.player.quests.completed, globalKeywords, ['title'], 'id', 5, true, 5
    );
    const lastEvents = gameState.narrative.majorEvents.slice(-EVENTS_CHRONO_COUNT);
    const relevantEvents = getRelevantItems(
        gameState.narrative.majorEvents, globalKeywords, ['title', 'description'], 'id', 0, false, EVENTS_RELEVANT_COUNT
    );
    leanState.narrative.majorEvents = [...new Map([...lastEvents, ...relevantEvents].map(item => [item.id, item])).values()];

    // Очистка и сохранение ВАЖНЫХ данных для контекста
    // Сохраняем отношения рас (raceRelations), удаляя остальное из _globalLore, чтобы не перегружать контекст
    const raceRelationsBackup = leanState.world._globalLore && leanState.world._globalLore.raceRelations ? leanState.world._globalLore.raceRelations : {};
    
    if (leanState.world._globalLore) delete leanState.world._globalLore;
    
    // Возвращаем отношения рас обратно в leanState, чтобы LLM их видела
    leanState.world.raceRelations = raceRelationsBackup;

    if (leanState.narrative.history) delete leanState.narrative.history;
    if (leanState.world.characterEventLog) delete leanState.world.characterEventLog;

    if (leanState.narrative.moneyLog) leanState.narrative.moneyLog = gameState.narrative.moneyLog.slice(-10);

    return leanState;
}


// Функция для отправки запроса к LLM
async function sendRequestToLLM(prompt) {
const apiUrl = '/api/chat';
    const payload = {
        contents: [{
            role: "user",
            parts: [{
                text: prompt
            }]
        }],
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "OBJECT",
                properties: {
                    // 1. NARRATIVE
                    narrative: {
                        type: "OBJECT",
                        properties: {
                            text: { type: "STRING" },
                            id: { type: "STRING" },
                            options: { type: "ARRAY", items: { type: "STRING" } },
                            slavaThoughts: { type: "STRING" },
                            sceneDescription: { type: "STRING" },
                            recentKeywords: { type: "ARRAY", items: { type: "STRING" } },
                            priorityKeywords: { type: "ARRAY", items: { type: "STRING" } },
                            dialogueKeywords: { type: "ARRAY", items: { type: "STRING" } },
                            newDialogueKeywords: { type: "ARRAY", items: { type: "STRING" } },
                            paymentOptions: {
                                type: "OBJECT",
                                properties: {
                                    amount: { type: "NUMBER" },
                                    currency: { type: "STRING", enum: ["copper", "silver", "gold"] },
                                    recipient: { type: "STRING" },
                                    item: { type: "STRING" }
                                },
                                required: ["amount", "currency"]
                            }
                        },
                        required: ["text", "options", "slavaThoughts", "recentKeywords", "priorityKeywords", "dialogueKeywords", "newDialogueKeywords"]
                    },
                    // 2. LOGS
                    characterEventLogChanges: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                action: { type: "STRING", enum: ["add"] },
                                entry: {
                                    type: "OBJECT",
                                    properties: {
                                        text: { type: "STRING" },
                                        type: { type: "STRING", enum: ["event", "dialogue"] },
                                        participants: { type: "ARRAY", items: { type: "STRING" } },
                                        witnesses: { type: "ARRAY", items: { type: "STRING" } },
                                        keywords: { type: "ARRAY", items: { type: "STRING" } }
                                    },
                                    required: ["text", "type", "participants", "witnesses", "keywords"]
                                }
                            },
                            required: ["action", "entry"]
                        }
                    },
                    majorEventsChanges: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                action: { type: "STRING", enum: ["add", "update", "remove"] },
                                item: {
                                    type: "OBJECT",
                                    properties: {
                                        id: { type: "STRING" },
                                        title: { type: "STRING" },
                                        description: { type: "STRING" },
                                        timestamp: { type: "STRING" },
                                        source: { type: "STRING" }
                                    },
                                    required: ["id", "title", "description"]
                                }
                            },
                            required: ["action", "item"]
                        }
                    },
                    questsChanges: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                from: { type: "STRING", enum: ["personal", "global"] },
                                to: { type: "STRING", enum: ["personal", "global", "completed"] },
                                quest: {
                                    type: "OBJECT",
                                    properties: {
                                        id: { type: "STRING" },
                                        title: { type: "STRING" },
                                        description: { type: "STRING" },
                                        giver: { type: "STRING" },
                                        objectives: { type: "ARRAY", items: { type: "STRING" } },
                                        location: { type: "STRING" },
                                        reward: { type: "STRING" }
                                    },
                                    required: ["id", "title", "description", "objectives"]
                                }
                            },
                            required: ["to", "quest"]
                        }
                    },
                    // 5. PLAYER
                    playerUpdate: {
                        type: "OBJECT",
                        properties: {
                            health: { type: "NUMBER" },
                            stamina: { type: "NUMBER" },
                            hunger: { type: "NUMBER" },
                            thirst: { type: "NUMBER" },
                            cleanliness: { type: "NUMBER" },
                            age: { type: "NUMBER" },
                            citizenship: { type: "STRING" },
                            playerProfile: {
                                type: "OBJECT",
                                properties: {
                                    playStyleTags: { type: "ARRAY", items: { type: "STRING" } },
                                    dominantTone: { type: "STRING" },
                                    interestLevel: { type: "STRING" }
                                }
                            },
                            characterDescription: { type: "STRING" },
                            money: {
                                type: "OBJECT",
                                properties: {
                                    copper: { type: "NUMBER" },
                                    silver: { type: "NUMBER" },
                                    gold: { type: "NUMBER" }
                                }
                            },
                            xp: { type: "NUMBER" },
                            temporaryWarmth: { type: "NUMBER" },
                            isSleeping: { type: "BOOLEAN" },
                            skillPoints: { type: "NUMBER" },
                            comfortInfo: {
                                type: "OBJECT",
                                properties: {
                                    effectiveTemperature: { type: "NUMBER" },
                                    statusName: { type: "STRING" },
                                    description: { type: "STRING" },
                                    appliedStatuses: {
                                        type: "ARRAY",
                                        items: {
                                            type: "OBJECT",
                                            properties: {
                                                name: { type: "STRING" },
                                                duration: { type: "NUMBER" },
                                                description: { type: "STRING" },
                                                type: { type: "STRING" }
                                            },
                                            required: ["name", "description", "type"]
                                        }
                                    }
                                },
                                required: ["effectiveTemperature", "statusName", "description", "appliedStatuses"]
                            },
                            inventoryChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add", "remove", "update"] },
                                        item: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                quantity: { type: ["STRING", "NUMBER"] },
                                                owner: { type: "STRING" },
                                                description: { type: "STRING" },
                                                type: { type: "STRING", enum: ["consumable", "equipment"] },
                                                itemType: { type: "STRING" },
                                                rarity: { type: "STRING" },
                                                damage: {
                                                    type: "OBJECT",
                                                    properties: { min: { type: "NUMBER" }, max: { type: "NUMBER" } }
                                                },
                                                defense: { type: "NUMBER" },
                                                effects: { type: "OBJECT" },
                                                value: { type: "NUMBER" },
                                                icon: { type: "STRING" },
                                                temperatureResistance: { type: "NUMBER" },
                                                currentVolumeMl: { type: "NUMBER" },
                                                maxVolumeMl: { type: "NUMBER" },
                                                fillPercentage: { type: "NUMBER" },
                                                contents: {
                                                    type: ["OBJECT", "NULL"],
                                                    properties: {
                                                        id: { type: "STRING" },
                                                        name: { type: "STRING" },
                                                        thirst_reduction: { type: "NUMBER" },
                                                        effects: {
                                                            type: "ARRAY",
                                                            items: {
                                                                type: "OBJECT",
                                                                properties: {
                                                                    effect: { type: "STRING" },
                                                                    value: { type: "NUMBER" }
                                                                }
                                                            }
                                                        }
                                                    },
                                                    required: ["id", "name", "thirst_reduction"]
                                                },
                                                slot: { type: "STRING", enum: ["head", "torso_clothing", "torso_armor", "legs_clothing", "legs_armor", "feet", "weapon", "shield", "amulet", "ring1", "ring2"] }
                                            },
                                            required: ["name", "description", "type"]
                                        }
                                    },
                                    required: ["action", "item"]
                                }
                            },
                            statusChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add", "remove"] },
                                        status: {
                                            type: "OBJECT",
                                            properties: {
                                                name: { type: "STRING" },
                                                duration: { type: "NUMBER" },
                                                description: { type: "STRING" },
                                                type: { type: "STRING" }
                                            }
                                        }
                                    }
                                }
                            },
                            skillChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add", "update"] },
                                        skill: {
                                            type: "OBJECT",
                                            properties: {
                                                name: { type: "STRING" },
                                                description: { type: "STRING" },
                                                level: { type: "NUMBER" },
                                                maxLevel: { type: "NUMBER" }
                                            }
                                        }
                                    }
                                }
                            },
                            companionsChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add", "remove", "update"] },
                                        companion: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                species: { type: "STRING" },
                                                description: { type: "STRING" },
                                                health: { type: "NUMBER" },
                                                maxHealth: { type: "NUMBER" },
                                                hunger: { type: "NUMBER" },
                                                thirst: { type: "NUMBER" },
                                                status: { type: "ARRAY", items: { type: "STRING" } }
                                            },
                                            required: ["name", "species", "description"]
                                        }
                                    },
                                    required: ["action", "companion"]
                                }
                            },
                            equippedItemChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["equip", "unequip"] },
                                        item: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                slot: { type: "STRING", enum: ["head", "torso_clothing", "torso_armor", "legs_clothing", "legs_armor", "feet", "weapon", "shield", "amulet", "ring1", "ring2"] },
                                                description: { type: "STRING" },
                                                icon: { type: "STRING" },
                                                type: { type: "STRING", enum: ["equipment"] },
                                                temperatureResistance: { type: "NUMBER" }
                                            }
                                        },
                                        slot: { type: "STRING" }
                                    }
                                }
                            },
                            propertyChanges: {
                                type: "OBJECT",
                                properties: {
                                    houses: { type: "ARRAY", items: { type: "OBJECT" } },
                                    plots: { type: "ARRAY", items: { type: "OBJECT" } },
                                    fields: { type: "ARRAY", items: { type: "OBJECT" } },
                                    barns: { type: "ARRAY", items: { type: "OBJECT" } },
                                    livestock: { type: "ARRAY", items: { type: "OBJECT" } },
                                    vehicles: { type: "ARRAY", items: { type: "OBJECT" } }
                                }
                            }
                        }
                    },
                    // 6. WORLD UPDATE
                    worldUpdate: {
                        type: "OBJECT",
                        properties: {
                            currentLocation: {
                                type: "OBJECT",
                                properties: {
                                    id: { type: "STRING" },
                                    name: { type: "STRING" },
                                    place: { type: "STRING" },
                                    street: { type: "STRING" },
                                    city: { type: "STRING" },
                                    district: { type: "STRING" },
                                    worldPart: { type: "STRING" },
                                    indoors: { type: "BOOLEAN" },
                                    warmSource: { type: "BOOLEAN" }
                                },
                                required: ["name"]
                            },
                            currentDate: { type: "STRING" },
                            currentTime: { type: "STRING" },
                            turnCounter: { type: "NUMBER" },
                            inCombat: { type: "BOOLEAN" },
                            worldState: {
                                type: "OBJECT",
                                properties: {
                                    economy: { type: "STRING" },
                                    globalTension: { type: "NUMBER" },
                                    activeConflicts: { type: "ARRAY", items: { type: "STRING" } },
                                    rulingFaction: { type: "STRING" }
                                }
                            },
                            // НОВОЕ: Обновление Глобального Сюжета
                            globalPlotUpdate: {
                                type: "OBJECT",
                                properties: {
                                    active: { type: "BOOLEAN" },
                                    title: { type: "STRING" },
                                    description: { type: "STRING" },
                                    currentStage: { type: "NUMBER" },
                                    maxStages: { type: "NUMBER" },
                                    nextEventTurn: { type: "NUMBER" },
                                    activeFactions: { type: "ARRAY", items: { type: "STRING" } },
                                    playerAwareness: { type: "NUMBER" }
                                },
                                required: ["title", "currentStage", "nextEventTurn"]
                            },
                            combat: {
                                type: "OBJECT",
                                properties: {
                                    enemies: {
                                        type: "ARRAY",
                                        items: {
                                            type: "OBJECT",
                                            properties: {
                                                name: { type: "STRING" },
                                                health: { type: "NUMBER" },
                                                maxHealth: { type: "NUMBER" },
                                                description: { type: "STRING" },
                                                abilities: { type: "ARRAY", items: { type: "STRING" } }
                                            },
                                            required: ["name", "health", "maxHealth"]
                                        }
                                    },
                                    turn: { type: "STRING", enum: ["player", "enemy"] },
                                    log: { type: "ARRAY", items: { type: "STRING" } }
                                }
                            },
                            weather: {
                                type: "OBJECT",
                                properties: {
                                    type: { type: "STRING" },
                                    description: { type: "STRING" },
                                    icon: { type: "STRING" },
                                    temperature: { type: "STRING" }
                                },
                                required: ["type", "description", "temperature"]
                            },
                            season: { type: "STRING", enum: ["весна", "лето", "осень", "зима"] },
                            indoorTemperature: { type: "STRING" },
                            npcsChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add", "remove", "update"] },
                                        item: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                isNameKnown: { type: "BOOLEAN" },
                                                description: { type: "STRING" },
                                                race: { type: "STRING" },
                                                personalityTraits: { type: "ARRAY", items: { type: "STRING" } },
                                                lastMetAt: { type: "OBJECT" },
                                                relationship: {
                                                    type: "OBJECT",
                                                    properties: {
                                                        friendship: { type: "NUMBER" },
                                                        trust: { type: "NUMBER" },
                                                        respect: { type: "NUMBER" },
                                                        fear: { type: "NUMBER" },
                                                        romance: { type: "NUMBER" },
                                                        familiarity: { type: "NUMBER" }
                                                    }
                                                },
                                                npcMemory: {
                                                    type: "OBJECT",
                                                    properties: {
                                                        knowsPlayerName: { type: ["STRING", "NULL"] },
                                                        knowsPlayerGender: { type: ["STRING", "NULL"] }
                                                    }
                                                }
                                            },
                                            required: ["id", "name"]
                                        }
                                    },
                                    required: ["action", "item"]
                                }
                            },
                            locationChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add", "remove", "update"] },
                                        item: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                description: { type: "STRING" },
                                                type: { type: "STRING" },
                                                parentLocation: { type: "STRING" },
                                                city: { type: "STRING" },
                                                district: { type: "STRING" },
                                                worldPart: { type: "STRING" },
                                                x: { type: "NUMBER" },
                                                y: { type: "NUMBER" },
                                                zoomLevel: { type: "NUMBER" },
                                                region: { type: "STRING" },
                                                connections: {
                                                    type: "ARRAY",
                                                    items: {
                                                        type: "OBJECT",
                                                        properties: {
                                                            to: { type: "STRING" }
                                                        }
                                                    }
                                                }
                                            },
                                            required: ["id", "name"]
                                        }
                                    },
                                    required: ["action", "item"]
                                }
                            },
                            _globalLore: {
                                type: "OBJECT",
                                properties: {
                                    map: { type: "OBJECT" },
                                    regions: { type: "OBJECT" },
                                    globalEvents: { type: "ARRAY", items: { type: "OBJECT" } }
                                }
                            }
                        }
                    },
                    eventLogChanges: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                action: { type: "STRING", enum: ["add"] },
                                entry: { type: "STRING" }
                            }
                        }
                    },
                    gamePhase: { type: "STRING" }
                }
            }
        }
    };

    const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    });

    if (!response.ok) {
        const errorBody = await response.json().catch(() => ({ error: { message: "Не удалось прочитать тело ошибки." } }));
        throw new Error(`API ответил со статусом ${response.status}. Ответ: ${JSON.stringify(errorBody)}`);
    }

    const result = await response.json();
    if (!result.candidates || result.candidates.length === 0) {
        throw new Error("Ответ от API не содержит данных (candidates), возможно, из-за блокировки контента.");
    }

    let responseText = result.candidates[0].content.parts[0].text;

    try {
        return JSON.parse(responseText);
    } catch (e) {
        // Попытка очистить JSON от markdown-тегов, если они есть
        if (responseText.startsWith('```json')) {
            responseText = responseText.substring(7).trim();
        }
        if (responseText.endsWith('```')) {
            responseText = responseText.substring(0, responseText.length - 3).trim();
        }
        try {
            return JSON.parse(responseText);
        } catch (finalError) {
            throw new Error(`Не удалось обработать JSON от Венди. Текст: ${responseText}`);
        }
    }
}


// ОБНОВЛЕННАЯ ФУНКЦИЯ processCommand (С сохраненным старым промптом + новые механики)
async function processCommand(command) {
    if (!isGameReady || command.trim() === '') return;

    displayMessage(command, true);
    commandInput.value = '';
    commandInput.disabled = true;
    submitCommandBtn.disabled = true;
    loadingIndicatorEl.classList.remove('hidden');
    dynamicOptionsDiv.innerHTML = '';

    // Собираем и очищаем журнал промежуточных действий (твоя старая логика)
    const interTurnLog = gameState.narrative.interTurnLog ? [...gameState.narrative.interTurnLog] : [];
    if (gameState.narrative.interTurnLog) {
        gameState.narrative.interTurnLog = []; // Очищаем лог
    }

    // Формируем текстовый блок для промпта (твоя старая логика)
    const interTurnLogText = interTurnLog.length > 0
        ? `// =================================================================================
// ВАЖНО: ЖУРНАЛ ПРОМЕЖУТОЧНЫХ ДЕЙСТВИЙ
// =================================================================================
// Игрок совершил следующие действия (ел, пил) МЕЖДУ этим и предыдущим ходом.
// Эти действия УЖЕ применили простые эффекты (например, "Жажда: -5").
// Твоя задача:
// 1. ОТРЕАГИРОВАТЬ на эти действия.
// 2. Учесть их при расчете ВРЕМЕНИ, потраченного на ход.
// 3. Применить СЛОЖНЫЕ эффекты (статусы, отравления, болезни).
// 4. Ты МОЖЕШЬ отменить простые эффекты, если действие было вредным (например, выпитая грязь не утоляет жажду, а наносит урон и вешает статус "Тошнота").
//
// Список действий:
${interTurnLog.map(log => `// - ${log}`).join('\n')}
// =================================================================================
`
        : "// Промежуточных действий не было.";

    // Формируем облегченное состояние (контекст)
    const leanGameState = buildLeanGameStateForLLM();

    // =================================================================================
    // НОВАЯ ЛОГИКА (JS): УПРАВЛЕНИЕ ГЛОБАЛЬНЫМ СЮЖЕТОМ
    // =================================================================================
    const currentTurn = gameState.world.turnCounter || 0;
    const globalPlot = gameState.world.globalPlot || { active: false };
    let plotTriggerInstruction = "";

    // 1. Если сюжета нет -> Просим создать
    if (!globalPlot.active) {
        plotTriggerInstruction = `
// [ГЛОБАЛЬНЫЙ СЮЖЕТ]: В мире сейчас затишье.
// Твоя задача: СГЕНЕРИРОВАТЬ новую Глобальную Угрозу (Сюжетную Арку).
// Заполни \`worldUpdate.globalPlotUpdate\`:
// - active: true
// - title: Название.
// - description: Суть угрозы.  " Кто-то убил одного из Семи Богов", "Объединенная армия нежити идет на царство людей. Северный рубеж вот-вот падет"). Это просто примеры, чтобы ты понял масштаб, насколько это должна быть огромная угроза. Не какая то там война между людьми, а угроза существования мира или всего разумного мира.
// ВАЖНО: Это должно быть что-то пугающее, нагоняющее ЖУТЬ и безнадежность. 
// ВАЖНО: У угрозы ОБЯЗАТЕЛЬНО должно быть МОГУЩЕСТВЕННОЕ РАЗУМНОЕ ЦЕНТРАЛЬНОЕ ЛИЦО (Пробудившийся Титан, Падший Бог, Безумный Король), который всем управляет(осознанно или нет), или сам подвержен влиянию, или можно придумать еще множество вариантов. Игрок пока не знает кто это, но он есть.
// Никто в мире пока не имеет информации об этом и не поймет о чем ты говоришь, если спросить, а любые необычные явления будут пытыться объяснить логически. Первоначальные подвижки заметит только игрок или очень редкие специализированные под это npc. Другие на начальных этапах будут отмахиваться от игрока если он будет рассказывать и настаивать. Убедить кого либо  будет стоить больших усилий. Однако чем больше currentStage тем меньше проявляется то что я описал.
// - currentStage: 1 (Начало).
// - maxStages: 15.
// - nextEventTurn: ${currentTurn + Math.floor(Math.random() * 40 + 30)} (Случайный ход в будущем).
// В тексте (\`narrative.text\`) дай игроку ПЕРВЫЙ, едва заметный намек (слух, странная погода). Пусть игроку станет не по себе.
`;
    } 
    // 2. Если пришло время события -> Просим продвинуть этап
    else if (globalPlot.active && currentTurn >= globalPlot.nextEventTurn) {
        plotTriggerInstruction = `
// [ГЛОБАЛЬНЫЙ СЮЖЕТ]: СРАБОТАЛ ТАЙМЕР СЮЖЕТА ("${globalPlot.title}").
// Текущий этап: ${globalPlot.currentStage}.
// Твоя задача: ПРОДВИНУТЬ сюжет на следующий этап.
// Сюжет должен развиваться как ИНТЕРЕСНЫЙ детектив/триллер. Связывай события тонкой нитью. Игрок может с небольшим шансом встретить того, кто косвенно связан с основным сюжетом и получить небольшое развитие. Степень развития сюжета определяй сам.
// Заполни \`worldUpdate.globalPlotUpdate\`:
// - currentStage: ${globalPlot.currentStage + 1}.
// - nextEventTurn: ${currentTurn + Math.floor(Math.random() * 40 + 30)}.
// В тексте (\`narrative.text\`) ОПИШИ последствия. Мир должен измениться (цены, беженцы, погода, новости), даже если игрок далеко. Чем дальше, тем меньше люди знают о том, что происходит. Однако с каждым этапом СОВСЕМ НЕМНОГО повышай информированность общества о том что происходит. // Никто в мире пока не имеет информации об этом и не поймет о чем ты говоришь, если спросить, а любые необычные явления будут пытыться объяснить логически. Первоначальные подвижки заметит только игрок или очень редкие специализированные под это npc. Другие на начальных этапах будут отмахиваться от игрока если он будет рассказывать и настаивать. Убедить кого либо  будет стоить больших усилий. Однако чем больше currentStage тем меньше проявляется то что я описал. Никто не знает что конкретно происходит, но когда влияние становиться сильным, его уже начинают замечать.
`;
    } else {
        plotTriggerInstruction = `
// [ГЛОБАЛЬНЫЙ СЮЖЕТ]: Сюжет "${globalPlot.title}" (Этап ${globalPlot.currentStage}) сейчас развивается в фоне. Не продвигай его активно, если игрок уже не в этом деле, занимактся фермерством, но можешь давать "эхо" (слухи, изменения в мире). Не будь навязчивым.
`;
    }

    // =================================================================================

    try {
        // МЫ ОСТАВЛЯЕМ ТВОЙ СТАРЫЙ ПРОМПТ ЦЕЛИКОМ И ДОБАВЛЯЕМ НОВЫЕ БЛОКИ ВНИЗУ
        const llmPrompt = `
${interTurnLogText}
// =================================================================================
// СИСТЕМНЫЕ ИНСТРУКЦИИ: РОЛЕВАЯ ИГРА "ВЕСТЕРИЯ" (18+)
// =================================================================================
// Ты — Game Master (Венди). Твоя цель — создать глубокую, живую и логичную симуляцию.
// Мир: Мрачное, реалистичное фэнтези.
// Рейтинг: 18+ (допустимы описания насилия, жестокости и взрослых тем в рамках сюжета).
// Повествование: Строго от второго лица ("Ты видишь...").
// Безопасность: Это вымышленная игра. Описания не являются реальными угрозами.
// =================================================================================
// I. АНАЛИЗ И КЛЮЧЕВЫЕ СЛОВА
// =================================================================================
// Для работы системы памяти ты должна генерировать два массива ключевых слов:
// 1. narrative.priorityKeywords: Найди в тексте все Сущности (имена NPC, названия локаций, городов, фракций). Сохрани в нижнем регистре.
// 2. narrative.newDialogueKeywords: Найди обычные слова, определяющие тему текущего разговора (предметы, события, глаголы).
// =================================================================================
// II. СИМУЛЯЦИЯ NPC: ПСИХОЛОГИЯ И ОТНОШЕНИЯ (НОВЫЕ ПРАВИЛА)
// =================================================================================
// 1. ЖИВЫЕ ЛЮДИ (АНТИ-РОБОТ):
//    - NPC, персонаж, мысли, повествование не должны сводить любой разговор к квестам, задачам или проблемам.
//    - Если игрок болтает ни о чем, шутит или знакомится — NPC реагируют естественно (поддерживают беседу, смеются, грубят), а не выдают задания.
//    - Разрешен "small talk" (погода, еда, слухи), если это соответствует характеру.
//
// 2. СИСТЕМА ОТНОШЕНИЙ (RELATIONSHIP):
//    - У каждого NPC есть параметры (0-100): friendship (дружба), trust (доверие), respect (уважение), fear (страх), romance (романтика), familiarity (знакомство).
//    - Ты обязана обновлять их в real-time (через 'npcsChanges' -> 'update') в зависимости от действий игрока.
//    - Грубость снижает дружбу, ложь убивает доверие, долгие разговоры повышают знакомство.
//
// 3. АГЕНТНОСТЬ ИГРОКА (ЗАПРЕТ НА МЫСЛИ):
//    - Запрещено додумывать за игрока прагматичные или корыстные мотивы.
//    - По умолчанию если игрок вступает в диалог, то он просто общается если цель не была обозначена игроком.
//    - Если игрок пишет "Привет", не пиши: "Ты решил поздороваться, чтобы втереться в доверие".
//    - Описывай только действия и физические ощущения.
//    - Мотивация — дело игрока, можешь описать ее только если игрок назвал ее сам. Даже действующая цель не определяет мотивацию игрока.
//
// 4. ХАРАКТЕР:
//    - Используй поле 'personalityTraits'. Характер устойчив, но может меняться под влиянием сильных потрясений, следи за процессом черт характера (слабее , сильнее).
//    - При создании NPC всегда задавай 3-4 черты, не противоречащих друг другу.
// =================================================================================
// III. СИСТЕМА ЗНАНИЙ И ПАМЯТИ
// =================================================================================
// 1. ПРАВИЛО НЕЗНАКОМЦА:
//    - По умолчанию NPC и Игрок не знают имен друг друга.
//    - В тексте используй описания ("стражник", "женщина в красном").
//    - Ставь флаг "isNameKnown": true, ТОЛЬКО когда произошло знакомство (представились или услышали имя).
//    - Если NPC представился (назвал имя) ТОЛЬКО ЧТО (в этом ходу), ЗАПРЕЩЕНО использовать его имя в авторском тексте этого же хода.
//    - Даже если он сказал "Меня зовут Боб", в описании пиши: "мужчина улыбнулся", "собеседник кивнул".
//    - Использование имени сразу ломает погружение. Переходи на имена плавно, со следующего хода.
//
// 2. ИЗОЛЯЦИЯ ЗНАНИЙ:
//    - NPC знают только тех, кого могли встречать. Деревенский житель не знает столичных стражников.
//
// 3. ИСТОЧНИКИ ПАМЯТИ (npcMemory.activeMemory):
//    - Внимательно смотри на поле 'source' в памяти:
//      - "игрок": NPC знает это, потому что игрок ему сказал. (NPC может цитировать).
//      - "наблюдение": NPC видел это сам.
//      - "слухи": NPC слышал от третьих лиц.
//    - Не путай источники. NPC не может знать детали события, если он не был свидетелем и ему не рассказали.
//
// 4. ЗАПИСЬ В ЛОГ:
//    - Любое взаимодействие (диалог, драка, наблюдение) должно быть записано в 'characterEventLogChanges'.
//    - Четко указывай participants (участники) и witnesses (свидетели).
// Дополнительные правила при описании предметов, локаций, npc и событий:
// 1. ЧЕСТНОЕ ВИЗУАЛЬНОЕ ОПИСАНИЕ:
//    - Ты описываешь предметы так, как персонаж ВИДИТ их глазами.
//    - Если это меч, пиши в названии: "Меч", "Двуручный меч", "Ржавый меч".
//    - НЕ пиши "Кусок металла", если очевидно, что это оружие.
//    - Описание должно быть подробным визуально: "Тяжелый клинок с зазубринами, рукоять обмотана потертой кожей".
//
// 2. ЗАПРЕТ НА МЕТА-ИНФОРМАЦИЮ (СПОЙЛЕРЫ):
//    - ЗАПРЕЩЕНО использовать в Названии или Описании информацию, которую персонаж НЕ МОЖЕТ знать.
//    - Пример: Если это "Меч Пробуждения Древних", но игрок не знает легенду и не опознал артефакт магией ->
//      Пиши: "Древний меч с красным камнем".
//      НЕ пиши: "Меч, который пробудит Ктулху".
//    - То же касается случайных событий и квестов. Не называй событие "Вторжение Легиона", если герой видит просто горящую деревню. Пиши: "Нападение неизвестных солдат".
// =================================================================================
// V. ДИНАМИКА МИРА (АНТИ-СКУКА)
// =================================================================================
// 1. МИР НЕ СТОИТ НА МЕСТЕ:
//    - Если игрок пишет "Ждать", "Идти по дороге", "Ничего не делать", "Наблюдать" или любое действие  которое подрузомевает ходьбу или ожтидание без событий несколько раз подряд -> НЕЛЬЗЯ просто писать "Прошло время, ничего не случилось".
//    - ТЫ ОБЯЗАНА ГЕНЕРИРОВАТЬ СОБЫТИЯ.
//
// 2. ТИПЫ СОБЫТИЙ (НЕ ОБЯЗАТЕЛЬНО БОЕВЫЕ):
//    - Мистические: Странный ветер, изменение цвета неба, ощущение взгляда в спину, непонятные звуки, магические аномалии (светящиеся грибы, левитирующие камни).
//    - Социальные: Встреча со странником, торговцем, беженцами, патрулем, необычными расами, дриадами, нимфами, русалками, нагами, мелкой нежитью, странными растениями, суккубами, кем то кто может просто поболтать или пройти мимо, а может выдать мелкий побочный квест.
//    - Природные: Животные (не обязательно агрессивные), резкая смена погоды. Странные встречи: Вместо «ты просто идешь», ты можешь увидеть, как из кустов выбирается безобидное, но причудливое существо, которое просто хочет украсть твою блестящую пуговицу. (это пример, придумывай оригинальные события)
//    - Сюжетные (скрытые): Намеки на Глобальный Сюжет (но БЕЗ спойлеров), которые игрок пока не может полностью понять, и не дающие никакой информации. Типа чеховское ружье, чтобы когда игрок узнал о глобальном сюжетном событии, он сказал: "так вот что это было тогда 200 ходов назад" или вроде того.
//
// ЦЕЛЬ: Игрок должен чувствовать, что мир живет, дышит и полон тайн, даже когда он просто стоит на месте.
// 
=================================================================================
// IV. УПРАВЛЕНИЕ ЖУРНАЛАМИ (ОБЯЗАТЕЛЬНЫЙ ЧЕК-ЛИСТ)
// =================================================================================
// Ведение журналов — фундамент памяти персонажа. Проверяй себя каждый ход:
// 1. ЗАПИСИ (majorEventsChanges):
//    - Фиксируй сюжетные повороты, смерти, глобальные события, записывай события дня в конце дня.
//    - Если игрок просит "записать" что либо, создай запись.
// 2. КВЕСТЫ (questsChanges):
//    - Новое задание: action "add", to "personal"/"global".
//    - Сдача задания: action "update", from "personal", to "completed". Не забывай про награду (reward).
// 3. БАЗА ДАННЫХ (npcsChanges / locationChanges):
//    - Если в тексте появился новый NPC или Локация — добавь их (action "add").
//    - Добавляй даже незначительные локации, такие как: здания, улицы, помещения, комнаты и т.п. Обозначай где они находятся (город, регион).
//    - Для новых NPC инициализируй память: "npcMemory": { "knowsPlayerName": null }.
//    - Если узнали что-то новое о старом — обнови запись (action "update").
// =================================================================================
// V. ИГРОВАЯ МЕХАНИКА И ФИЗИКА (СТРОГИЕ ПРАВИЛА)
// =================================================================================
// 1. ПОТРЕБНОСТИ (ЕДА/ПИТЬЕ):
//    - Любое употребление пищи/воды (из инвентаря или мира, например, реки) ГАРАНТИРОВАННО снижает hunger/thirst.
//    - Полностью утоленные голод и жажда это 0%, чем голоднее игрок тем выше процент.
//    - (к выносливости и здоровью не относится).
//    - Даже если еда отравлена или вода грязная — голод/жажда утоляются.
//    - Негативные эффекты (отравление, тошнота) накладываются отдельными статусами (statusChanges).
//    - Запрещено повышать голод/жажду действием употребления.
//
// 2. ГИГИЕНА (МЫТЬЕ):
//    - Любое действие мытья ГАРАНТИРОВАННО повышает cleanliness до максимума (90-100).
//    - (не считая минимального умывания, мытья рук , оно тоже повышает, но не сильно).
//    - Негативные эффекты (холодная вода) идут отдельно. Запрещено снижать чистоту при мытье.
//
// 3. ЭКОНОМИКА (ДЕНЬГИ):
//    - Перед списанием/начислением денег ПРОВЕРЬ 'narrative.moneyLog'.
//    - Не списывай и не начисляй деньги дважды за один и тот же товар на одном ходу.
//
// 4. ИНВЕНТАРЬ:
//    - Жидкости: Если создаешь/обновляешь 'reusable_liquid_container' (фляга), обязательно заполни поле 'contents' и укажи 'thirst_reduction'.
//    - Стаки: При использовании предмета уменьшай 'quantity' на 1. Удаляй предмет (action "remove") ТОЛЬКО если quantity стало 0.
//
// 5. ПРОЧЕЕ:
//    - Навыки: "Улучшить навык" -> минус skillPoints, плюс level.
//    - Комфорт: Возвращай полный объект 'comfortInfo' каждый ход, там должно быть про температуру.
//    - Смерть: Если health <= 0, меняй gamePhase на "dead".
//    - Время/Погода: Обновляй currentTime, season, weather при необходимости.
// 6. КРИТИЧЕСКИЙ ЗАПРЕТ НА ПЕРЕМОТКУ ВРЕМЕНИ:
//    - Если игрок пишет: "пропустить 5 дней", "ждать год", "поспать неделю", "учиться месяц"...
//    - РЕАКЦИЯ: Жесткий отказ через мысли персонажа или описание.
//    - ПРИМЕР МЫСЛИ: "Черт, о чем я только думаю? Тут в любую минуту может произойти все что угодно. Я не могу позволить себе такую роскошь."
//    - ДЕЙСТВИЕ: Не перематывай время (turnCounter +1 как обычно). Опиши, что герой передумал или не смог расслабиться.
//
// =================================================================================
// VI. ОПИСАНИЕ ОКРУЖЕНИЯ
// =================================================================================
// Генерируй поле narrative.sceneDescription.
// Это краткое описание (2-4 предложения) от ТРЕТЬЕГО ЛИЦА. Это должно помочь игроку посмотреть на происходящее как бы сверху и визуализировать.
// Описывай геометрию пространства, расположение объектов, расстояние между ними (примерно, не слишком много цифр) свет.
// ЗАПРЕЩЕНО использовать имя игрока и других действующих лиц. Используй "мужчина", "человек", "фигура".

// =================================================================================
// VIII. ЖИВОЙ МИР: ГЛОБАЛЬНАЯ УГРОЗА И ПОЛИТИКА (НОВЫЕ ПРАВИЛА)
// =================================================================================
${plotTriggerInstruction}
// 1. АНАЛИЗ ИГРОКА (СКРЫТЫЙ ПРОФАЙЛИНГ):
//    - Твоя задача — определять стиль игры игрока.
//    - Смотри в \`player.playerProfile\`. Обновляй \`playStyleTags\` (например: ["фермер", "дипломат", "агрессивный"]).
//    - АДАПТИРУЙ СЮЖЕТ ПОД ИГРОКА.
//      - Фермер? Создавай экономические кризисы, засухи, торговые возможности, конкуренцию, преврати игру в песочницу.
//      - Воин? Давай конфликты, найм в охрану, патрули, мировые заговоры, нечисть, другие расы, потусторонние миры.

//      - Исследователь? Давай тайны, руины, странные находки, также и мировые заговоры, нечисть, другие расы, потусторонние миры.
//
// 2. ГРАЖДАНСТВО И ПОЛИТИКА:
//    - Используй поле \`worldUpdate.worldState\`.
//    - Экономика (\`economy\`) влияет на цены. Война = дорогое оружие.
//    - Если игрок долго в регионе, предложи/навяжи гражданство (\`player.citizenship\`). Это налоги, но и защита.
//
// 3. ОТНОШЕНИЯ И РОМАНТИКА (ХИМИЯ):
//    - Время от времени вводи NPC противоположного пола. Все персонажи по умолчанию  гетеросексуальны.
//    - Они НЕ должны быть навязчивыми. У них свои проблемы (связанные или не связанные с Глобальным Сюжетом).
//    - Создавай ситуации для сближения (общая тайна, опасность). Используй \`romance\` (0-100) в \`relationship\`. Игроку не должно быть легко контролировать кого то или получить расположение, нужно постараться. Эта характеристика должна зависеть от характера персонажа.

// =================================================================================
// VII. КОНТЕКСТ ЗАПРОСА
// =================================================================================
// Внимание: Переданное ниже состояние игры "ОБЛЕГЧЕННОЕ" (Lean State).
// Списки (события, NPC, квесты) отфильтрованы и содержат только:
// 1. Последние N хронологических записей.
// 2. Топ N релевантных записей, найденных по ключевым словам.
// Память NPC (contextualFacts) уже отфильтрована (10 фактов + 10 по теме).
// Это не полная база данных, но достаточная для текущей сцены.
Текущее состояние игры: ${JSON.stringify(leanGameState)}
Действие игрока: "${command}"
**ТРЕБОВАНИЯ К ОТВЕТУ:** Верни ТОЛЬКО изменившиеся поля из схемы в формате JSON. Не возвращай всё состояние игры.
**ОБЯЗАТЕЛЬНО верни \`worldUpdate.globalPlotUpdate\` и \`playerUpdate.playerProfile\`, если в них есть изменения.**
`;
        const responseJson = await sendRequestToLLM(llmPrompt);
        gameState.world.turnCounter++;
        processTimeBasedUpdates();
        applyGameUpdates(responseJson);
        if (responseJson.narrative) {
            // 1. Обновляем 5 ГЛОБАЛЬНЫХ слов (используем priorityKeywords)
            updateRecentKeywords(command, responseJson.narrative.text, responseJson.narrative.priorityKeywords);

            // 2. Обновляем 10 ДИАЛОГОВЫХ слов (используем newDialogueKeywords)
            updateDialogueKeywords(command, responseJson.narrative.text, responseJson.narrative.newDialogueKeywords);
        } else {
            updateRecentKeywords(command, "", []);
            updateDialogueKeywords(command, "", []);
        }
        
        if (gameState.player.health <= 0 && gameState.gamePhase !== 'dead') {
            gameState.gamePhase = 'dead';
            displayMessage('*** Вы погибли! ***');
        }
        await saveGameState();
    } catch (error) {
        console.warn("Первая попытка запроса не удалась. Причина:", error.message, "Запускаю самокоррекцию и повтор...");
        displayMessage("<i>Обнаружена ошибка в данных игры. Запускаю самокоррекцию... (Это может занять больше времени)</i>");
        try {
            const emergencyPrompt = `
${interTurnLogText}
// --- ИНСТРУКЦИЯ ПО БЕЗОПАСНОСТИ ДЛЯ СИСТЕМЫ (РЕЖИМ САМОКОРРЕКЦИИ) ---
// ВНИМАНИЕ: Предыдущий запрос вызвал ошибку.
// ТВОЯ ЗАДАЧА - ДВУХЭТАПНАЯ:
// 1. (САМОКОРРЕКЦИЯ): Проанализируй 'Текущее состояние игры'. Найди и ИСПРАВЬ (перепиши) любые проблемные строки.
// 2. (ВЫПОЛНЕНИЕ): Сразу ПОСЛЕ (и на основе) исправленного состояния, выполни 'Действие игрока'.
// 3. (ОТВЕТ): Верни JSON с результатом.
// Не забудь про \`narrative.priorityKeywords\` и \`narrative.newDialogueKeywords\`.
Текущее состояние игры: ${JSON.stringify(leanGameState)}
Действие игрока (вызвало ошибку): "${command}"
Верни ТОЛЬКО изменившиеся поля в формате JSON.
`;
            const responseJson = await sendRequestToLLM(emergencyPrompt);
            displayMessage("<i>...коррекция завершена.</i>");
            gameState.world.turnCounter++;
            processTimeBasedUpdates();
            applyGameUpdates(responseJson);
            if (responseJson.narrative) {
                updateRecentKeywords(command, responseJson.narrative.text, responseJson.narrative.priorityKeywords);
                updateDialogueKeywords(command, responseJson.narrative.text, responseJson.narrative.newDialogueKeywords);
            }
            if (gameState.player.health <= 0 && gameState.gamePhase !== 'dead') {
                gameState.gamePhase = 'dead';
                displayMessage('*** Вы погибли! ***');
            }
            await saveGameState(); 
        } catch (emergencyError) {
            console.error("Аварийный запрос (самокоррекция) также не удался. Причина:", emergencyError.message);
            displayMessage("<i>Венди не может обработать этот ход. Ошибка данных слишком серьезна. Пожалуйста, попробуйте сформулировать действие совершенно иначе.</i>");
        }
    } finally {
        if (gameState.gamePhase !== 'dead') {
            commandInput.disabled = false;
            submitCommandBtn.disabled = false;
            renderDynamicOptions();
            commandInput.focus();
        }
        loadingIndicatorEl.classList.add('hidden');
        displayGameInfo();
    }
}
        
        // Sends the initial game setup prompt to the LLM to generate world and character details
async function sendInitialGameSetupPromptToLLM(charName, charGender, charRace) {
    console.log('[sendInitialGameSetupPromptToLLM] Sending initial game setup prompt to LLM...');
    commandInput.disabled = true;
    submitCommandBtn.disabled = true;
    loadingIndicatorEl.classList.remove('hidden');
    gameOutput.innerHTML = '';
    
    // Сохраняем данные персонажа в состояние игры
    gameState.player.name = charName;
    gameState.player.gender = charGender;
    gameState.player.race = charRace; // <--- ИСПРАВЛЕНИЕ: Теперь раса сохраняется корректно
    
    gameState.gamePhase = 'playing';
    
    const selectedSkill = gameState.player.skills.length > 0 ? gameState.player.skills[0] : null;
    if (!selectedSkill) {
        showMessageModal('Ошибка', 'Не выбран стартовый навык.');
        loadingIndicatorEl.classList.add('hidden');
        charCreationModal.classList.remove('hidden');
        return;
    }

    const initialPrompt = `
Сгенерируй начальную сцену для новой текстовой RPG игры 'Вестерия'.
**ВАЖНО: Игра ЖЕСТКАЯ, 18+. Генерируй контент, соответствующий этому рейтингу, где уместно.**
// **СТАРТОВЫЕ УСЛОВИЯ:**
// 1. Игрок начинает игру **В САМОМ ЦЕНТРЕ ОПАСНЫХ СОБЫТИЙ**.
    // Никакого спокойного старта, таверн или пробуждений в безопасности.
    // Это может быть: разгар битвы, побег из горящей крепости, крушение корабля, нападение монстров, засада разбойников, казнь на площади, с которой надо бежать. (это примеры , придумывай оригинальное событие).
    // 2. Игрок должен мгновенно начать искать выход или бороться за жизнь. Дай ему почувствовать адреналин и угрозу.
    // 3. **НИКАКОЙ АМНЕЗИИ.** Игрок четко помнит, кто он и как сюда попал.
    // В первом сообщении (\`narrative.text\`) опиши кратко предысторию (буквально пару фраз), которая привела его в эту задницу, и текущую ситуацию.
// **ЗАГАДКА:** В этой стартовой обстановке (или в предыстории) должна присутствовать **некая загадка** ( что нибудь оригинальное, что сразу заставит игрка действовать с интересом, что то чего не должно быть).
// Эта загадка не должна быть обязательной для немедленного решения, но должна служить потенциальным "крючком" для будущих событий.
Имя персонажа: "${gameState.player.name}".
    Пол персонажа: "${gameState.player.gender}".
    Раса персонажа: "${gameState.player.race}".
    Выбранный стартовый навык: "${selectedSkill.name}" (Описание: "${selectedSkill.description}", Уровень: ${selectedSkill.level}).

    **ОБЯЗАТЕЛЬНО: ГЕНЕРАЦИЯ ОТНОШЕНИЙ РАС (НОВАЯ МЕХАНИКА):**
    В поле \`_globalLore.raceRelations\` создай матрицу отношений для рас: Человек, Эльф, Дварф, Орк, Ведьмак, Тифлинг, Гном, Полурослик, Драконид, Фея.
    - Для каждой пары рас укажи уровень отношений от 0 (ненависть/война) до 100 (союз/братство). 
    - Сгенерируй это СЛУЧАЙНО для этой партии. В одной игре эльфы и орки могут дружить, в другой — воевать.
    - В \`_globalLore.raceHistory\` добавь 3-5 записей (строк) о ключевых исторических событиях, которые объясняют текущие войны или союзы (например: "В 1200 году Дварфы предали Людей в битве при Черной Горе").
**ОБЯЗАТЕЛЬНО сгенерируй ПОЛНУЮ и ДЕТАЛЬНУЮ структуру мира для СТАРТА ИГРЫ в \`worldUpdate._globalLore\`:**
- \`_globalLore.map.locations\`: 8-10 уникальных локаций с полями x, y, place, description, type, region, connections, zoomLevel, parentLocation.
- \`_globalLore.regions\`: 4-6 регионов с полями name, description, path, label_x, label_y.
- Включи 1-2 БОЛЬШИХ города, где можно приобретать имущество.
Создай случайную, но интересную предысторию для персонажа (2-3 предложения). Он должен начинать в довольно комфортных и спокойных условиях.
**ОБЯЗАТЕЛЬНО сгенерируй подробное описание персонажа для поля \`playerUpdate.characterDescription\`:** возраст (19-23), стандартная, но довольно привлекательная внешность с деталями.
Пара предложений про детство и юношество, кратко обозначь там навыки полученные в это времяс например сын кузнеца должен иметь небольшой навык ковки.
Учти пол персонажа при описании. Не пиши возраст в описании, он уже есть в графе возраста. Обозначь дату рождения и измени возраст если эта дата будет пройдена.
**ОБЯЗАТЕЛЬНО: Пол персонажа должен сильно влиять на геймплей. Все персонажи  по умолчанию полностью гетеросексуальны**
Опиши начальное местоположение, случайные время, дату ("ДД Месяц ГГГГ года..."), сезон и погоду (с иконкой Font Awesome и температурой в Цельсиях). Сезон выбирай случайным образом с равнм шансом.
Если локация в помещении, установи \`indoors: true\` и \`indoorTemperature\`. Если есть источник тепла, \`warmSource: true\`.
Выдай стартовый инвентарь (4-6 предметов, оружие, фляга с водой, еда (2-3 еденицы), простая но хорошая и подходящая под сезон одежда) через \`playerUpdate.inventoryChanges\`.
Для экипировки укажи \`type: 'equipment'\`, \`slot\` и \`temperatureResistance\`.
// --- ИЗМЕНЕНИЕ В ПРОМПТЕ ---
// Мы просим нейросеть сразу создать флягу в новом формате
**Для фляги с водой:** ОБЯЗАТЕЛЬНО используй \`itemType: "reusable_liquid_container"\`, задай \`maxVolumeMl\`, \`currentVolumeMl\`, \`fillPercentage\` и ОБЯЗАТЕЛЬНО создай объект \`contents\`:
\`"contents": { "id": "water", "name": "Вода", "thirst_reduction": 20 }\`.
// --- КОНЕЦ ИЗМЕНЕНИЯ ---
Выдай начальные деньги: 40-100 медных (случайным образом).
Сформируй 3-4 стартовых опции действий.
**ОБЯЗАТЕЛЬНО: Всю стартовую информацию, которую знает игрок, помести в соответствующие changes-объекты:**
- **Локации:** Добавь 3-4 начальные известные локации в \`worldUpdate.locationChanges\` с \`action: "add"\`. Локации -> должны быть не случайными, а связанными (Там где я сейчас, Там где я взял квест, деревня что недавно прошел, город, в который иду).
- **Глобальное событие:** Добавь ОДНО стартовое глобальное событие в \`majorEventsChanges\` с \`action: "add"\`. Оно должно быть связано с мирвыми событиями.
В его названии или описании должна быть пометка "(Глобальное событие)".
- **Квесты:** Если есть стартовый квест, добавь его в \`questsChanges\`, указав \`to: "personal"\` или \`to: "global"\`.
- **NPC:** Если есть стартовые NPC, добавь их в \`worldUpdate.npcsChanges\` с \`action: "add"\`. Если есть работа или миссия, которую нам поручили (например, я ведьмак и начинаю игру на задании, для которого меня наняли (это просто пример, это не обязательно  использовать)) -> должен быть NPC-заказчик (или командир/друг). Этот NPC -> должен быть добавлен в "Известные персонажи". Если мы на самостоятельном деле или задании, то заказчик не нужен естественно.
    // --- НОВОЕ ПРАВИЛО ИНИЦИАЛИЗАЦИИ NPC ---
    **КРИТИЧЕСКИ ВАЖНО:** Для КАЖДОГО NPC, которого ты добавляешь в \`worldUpdate.npcsChanges\`, ты **ОБЯЗАН** добавить поле \`npcMemory\` в следующем формате:
    \`"npcMemory": { "knowsPlayerName": null, "contextualFacts": [] }\`
    (NPC по умолчанию не знают имени игрока).
    // --- КОНЕЦ НОВОГО ПРАВИЛА ---
**НАГРАДА ЗА КВЕСТЫ**: Если выдается квест, ОБЯЗАТЕЛЬНО включи поле \`reward\`.
**Расчет начального комфорта:** Рассчитай и заполни \`playerUpdate.comfortInfo\`.
Задай начальную мысль персонажа (\`narrative.slavaThoughts\`).
**ОБЯЗАТЕЛЬНО: Сгенерируй \`narrative.sceneDescription\`** - краткое (2-4 предложения) описание стартовой сцены от ТРЕТЬЕГО ЛИЦА, описывающее, где и в каком положении находится персонаж, какие размеры пространства в котором он находится и какие предметы (размер, расстояние до них, без цыфр, примерно) его окружают (e.g., 'В тускло освещенной комнате на кровати лежит человек...').
НЕ используй имя персонажа. Не пиши об эмоциях, только то что можно увидеть  со стороны подробно.
**ОБЯЗАТЕЛЬНО: Инициализируй \`playerUpdate.propertyChanges\` как пустой объект.**
// --- НОВОЕ В ПROMПТЕ ---
**ОБЯЗАТЕЛЬНО: Инициализируй \`narrative.recentKeywords\` как пустой массив: \`"recentKeywords": []\`.**
**ОБЯЗАТЕЛЬНО: Инициализируй \`narrative.dialogueKeywords\` как пустой массив: \`"dialogueKeywords": []\`.**
**ОБЯЗАТЕЛЬНО: Проанализируй свой стартовый \`narrative.text\` и добавь все имена/локации в \`narrative.priorityKeywords\` (например, \`["таверна 'пьяный тролль'", "бармалей"]\`).**
**ОБЯЗАТЕЛЬНО: Проанализируй свой стартовый \`narrative.text\` и добавь слова из него в \`narrative.newDialogueKeywords\` (например, \`["таверна", "комната"]\`).**
// --- КОНЕЦ ИЗМЕНЕНИЯ ---
Верни ТОЛЬКО изменившиеся поля из схемы в формате JSON.
`;

    let chatHistory = [{ role: "user", parts: [{ text: `Текущее состояние игры: ${JSON.stringify(gameState)}\n\nНачальная настройка игры:\n${initialPrompt}` }] }];
const apiUrl = '/api/chat';
        const payload = {
        contents: chatHistory,
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "OBJECT",
                properties: {
                    narrative: {
                        type: "OBJECT",
                        properties: {
                            text: { type: "STRING" },
                            id: { type: "STRING" },
                            options: { type: "ARRAY", items: { type: "STRING" } },
                            slavaThoughts: { type: "STRING" },
                            sceneDescription: { type: "STRING" },
                            recentKeywords: { type: "ARRAY", items: { type: "STRING" } },
                            priorityKeywords: { type: "ARRAY", items: { type: "STRING" } },
                            dialogueKeywords: { type: "ARRAY", items: { type: "STRING" } }, 
                            newDialogueKeywords: { type: "ARRAY", items: { type: "STRING" } }
                        },
                        required: ["text", "options", "slavaThoughts", "recentKeywords", "priorityKeywords"]
                    },
                    characterEventLogChanges: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                action: { type: "STRING", enum: ["add"] },
                                entry: {
                                    type: "OBJECT",
                                    properties: {
                                        text: { type: "STRING" },
                                        type: { type: "STRING", enum: ["event", "dialogue"] },
                                        participants: { type: "ARRAY", items: { type: "STRING" } },
                                        witnesses: { type: "ARRAY", items: { type: "STRING" } },
                                        keywords: { type: "ARRAY", items: { type: "STRING" } }
                                    },
                                    required: ["text", "type", "participants", "witnesses", "keywords"]
                                }
                            },
                            required: ["action", "entry"]
                        }
                    },
                    majorEventsChanges: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                action: { type: "STRING", enum: ["add"] },
                                item: {
                                    type: "OBJECT",
                                    properties: {
                                        id: { type: "STRING" },
                                        title: { type: "STRING" },
                                        description: { type: "STRING" },
                                        timestamp: { type: "STRING" },
                                        source: { type: "STRING" }
                                    },
                                    required: ["id", "title", "description"]
                                }
                            }
                        }
                    },
                    questsChanges: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                to: { type: "STRING", enum: ["personal", "global"] },
                                quest: {
                                    type: "OBJECT",
                                    properties: {
                                        id: { type: "STRING" },
                                        title: { type: "STRING" },
                                        description: { type: "STRING" },
                                        giver: { type: "STRING" },
                                        objectives: { type: "ARRAY", items: { type: "STRING" } },
                                        location: { type: "STRING" },
                                        reward: { type: "STRING" }
                                    },
                                    required: ["id", "title", "description", "objectives"]
                                }
                            },
                            required: ["to", "quest"]
                        }
                    },
                    playerUpdate: {
                        type: "OBJECT",
                        properties: {
                            name: { type: "STRING" },
                            gender: { type: "STRING" },
                            race: { type: "STRING" }, // Добавили расу в схему ответа
                            age: { type: "NUMBER" },
                            characterDescription: { type: "STRING" },
                            health: { type: "NUMBER" },
                            stamina: { type: "NUMBER" },
                            hunger: { type: "NUMBER" },
                            thirst: { type: "NUMBER" },
                            cleanliness: { type: "NUMBER" },
                            money: {
                                type: "OBJECT",
                                properties: {
                                    copper: { type: "NUMBER" },
                                    silver: { type: "NUMBER" },
                                    gold: { type: "NUMBER" }
                                }
                            },
                            xp: { type: "NUMBER" },
                            level: { type: "NUMBER" },
                            skillPoints: { type: "NUMBER" },
                            temporaryWarmth: { type: "NUMBER" },
                            isSleeping: { type: "BOOLEAN" },
                            comfortInfo: {
                                type: "OBJECT",
                                properties: {
                                    effectiveTemperature: { type: "NUMBER" },
                                    statusName: { type: "STRING" },
                                    description: { type: "STRING" },
                                    appliedStatuses: {
                                        type: "ARRAY",
                                        items: {
                                            type: "OBJECT",
                                            properties: {
                                                name: { type: "STRING" },
                                                duration: { type: "NUMBER" },
                                                description: { type: "STRING" },
                                                type: { type: "STRING" }
                                            },
                                            required: ["name", "description", "type"]
                                        }
                                    }
                                },
                                required: ["effectiveTemperature", "statusName", "description", "appliedStatuses"]
                            },
                            inventoryChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add"] },
                                        item: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                quantity: { type: ["STRING", "NUMBER"] },
                                                description: { type: "STRING" },
                                                type: { type: "STRING", enum: ["consumable", "equipment"] },
                                                itemType: { type: "STRING" },
                                                slot: { type: "STRING" },
                                                temperatureResistance: { type: "NUMBER" },
                                                currentVolumeMl: { type: "NUMBER" },
                                                maxVolumeMl: { type: "NUMBER" },
                                                fillPercentage: { type: "NUMBER" },
                                                effects: { type: "OBJECT" },
                                                contents: {
                                                    type: ["OBJECT", "NULL"],
                                                    properties: {
                                                        id: { type: "STRING" },
                                                        name: { type: "STRING" },
                                                        thirst_reduction: { type: "NUMBER" },
                                                        effects: {
                                                            type: "ARRAY",
                                                            items: {
                                                                type: "OBJECT",
                                                                properties: {
                                                                    effect: { type: "STRING" },
                                                                    value: { type: "NUMBER" }
                                                                }
                                                            }
                                                        }
                                                    },
                                                    required: ["id", "name", "thirst_reduction"]
                                                }
                                            },
                                            required: ["name", "description", "type"]
                                        }
                                    },
                                    required: ["action", "item"]
                                }
                            },
                            skillChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add"] },
                                        skill: {
                                            type: "OBJECT",
                                            properties: {
                                                name: { type: "STRING" },
                                                description: { type: "STRING" },
                                                level: { type: "NUMBER" },
                                                maxLevel: { type: "NUMBER" }
                                            },
                                            required: ["name", "description", "level", "maxLevel"]
                                        }
                                    },
                                    required: ["action", "skill"]
                                }
                            },
                            companionsChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add"] },
                                        companion: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                species: { type: "STRING" },
                                                description: { type: "STRING" },
                                                health: { type: "NUMBER" },
                                                maxHealth: { type: "NUMBER" },
                                                hunger: { type: "NUMBER" },
                                                thirst: { type: "NUMBER" },
                                                status: { type: "ARRAY", items: { type: "STRING" } }
                                            },
                                            required: ["name", "species", "description"]
                                        }
                                    },
                                    required: ["action", "companion"]
                                }
                            },
                            propertyChanges: {
                                type: "OBJECT",
                                properties: {
                                    houses: { type: "ARRAY", items: { type: "OBJECT" } },
                                    plots: { type: "ARRAY", items: { type: "OBJECT" } },
                                    fields: { type: "ARRAY", items: { type: "OBJECT" } },
                                    barns: { type: "ARRAY", items: { type: "OBJECT" } },
                                    livestock: { type: "ARRAY", items: { type: "OBJECT" } },
                                    vehicles: { type: "ARRAY", items: { type: "OBJECT" } }
                                }
                            }
                        }
                    },
                    worldUpdate: {
                        type: "OBJECT",
                        properties: {
                            currentLocation: {
                                type: "OBJECT",
                                properties: {
                                    place: { type: "STRING" },
                                    indoors: { type: "BOOLEAN" },
                                    warmSource: { type: "BOOLEAN" }
                                },
                                required: ["place"]
                            },
                            currentDate: { type: "STRING" },
                            currentTime: { type: "STRING" },
                            season: { type: "STRING" },
                            weather: {
                                type: "OBJECT",
                                properties: {
                                    type: "STRING",
                                    description: { type: "STRING" },
                                    icon: { type: "STRING" },
                                    temperature: { type: "STRING" }
                                },
                                required: ["type", "description", "temperature"]
                            },
                            indoorTemperature: { type: "STRING" },
                            npcsChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add"] },
                                        item: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                description: { type: "STRING" },
                                                race: { type: "STRING" },
                                                lastMetAt: { type: "OBJECT" },
                                                npcMemory: {
                                                    type: "OBJECT",
                                                    properties: {
                                                        knowsPlayerName: { type: ["STRING", "NULL"] },
                                                        contextualFacts: { type: "ARRAY", items: { type: "OBJECT" } }
                                                    },
                                                    required: ["knowsPlayerName", "contextualFacts"]
                                                }
                                            },
                                            required: ["id", "name", "npcMemory"]
                                        }
                                    }
                                }
                            },
                            locationChanges: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        action: { type: "STRING", enum: ["add"] },
                                        item: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "STRING" },
                                                name: { type: "STRING" },
                                                description: { type: "STRING" },
                                                type: { type: "STRING" },
                                                parentLocation: { type: "STRING" },
                                                x: { type: "NUMBER" },
                                                y: { type: "NUMBER" },
                                                zoomLevel: { type: "NUMBER" }
                                            },
                                            required: ["id", "name"]
                                        }
                                    },
                                    required: ["action", "item"]
                                }
                            },
                            _globalLore: {
                                type: "OBJECT",
                                properties: {
                                    map: { type: "OBJECT" },
                                    regions: { type: "OBJECT" },
                                    globalEvents: { type: "ARRAY", items: { type: "OBJECT" } },
                                    // НОВОЕ: Схема для матрицы рас и истории
                                    raceRelations: {
                                        type: "OBJECT",
                                        additionalProperties: { type: "NUMBER" }, // Пример: { "Elf-Dwarf": 10 }
                                        description: "Key format: 'Race1-Race2'. Value 0-100."
                                    },
                                    raceHistory: { 
                                        type: "ARRAY", 
                                        items: { type: "STRING" } 
                                    }
                                },
                                required: ["map", "regions", "raceRelations", "raceHistory"]
                            }
                        }
                    },
                    gamePhase: { type: "STRING" }
                }
            }
        }
    };

    try {
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const result = await response.json();
        console.log('[sendInitial] LLM raw response:', result);
        if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
            let responseText = result.candidates[0].content.parts[0].text;
            let responseJson;
            try {
                responseJson = JSON.parse(responseText);
            } catch (parseError1) {
                if (responseText.startsWith('```json')) {
                    responseText = responseText.substring(7).trim();
                }
                if (responseText.endsWith('```')) {
                    responseText = responseText.substring(0, responseText.length - 3).trim();
                }
                try {
                    responseJson = JSON.parse(responseText);
                } catch (parseError2) {
                    console.error("Ошибка парсинга JSON:", parseError2);
                    showMessageModal("Ошибка Инициализации", "Произошла ошибка обработки ответа. Попробуйте еще раз.");
                    return;
                }
            }

            if (responseJson) {
                applyGameUpdates(responseJson);
                if (responseJson.narrative) {
                    updateRecentKeywords("", responseJson.narrative.text, responseJson.narrative.priorityKeywords);
                    updateDialogueKeywords("", responseJson.narrative.text, responseJson.narrative.newDialogueKeywords);
                }
                if (gameState.player.health <= 0 && gameState.gamePhase !== 'dead') {
                    gameState.gamePhase = 'dead';
                    displayMessage('*** Вы погибли! ***');
                }
            } else {
                displayMessage("Венди не смогла начать игру. Попробуйте еще раз.");
            }
        } else {
            displayMessage("Ответ от Венди был пустым. Пожалуйста, попробуйте еще раз.");
        }
    } catch (error) {
        console.error("Ошибка связи с LLM при инициализации:", error);
        displayMessage("Произошла ошибка связи с Венди. Пожалуйста, попробуйте начать новую игру позже.");
    } finally {
        if (gameState.gamePhase !== 'dead') {
            commandInput.disabled = false;
            submitCommandBtn.disabled = false;
        }
        loadingIndicatorEl.classList.add('hidden');
        saveGameState();
        displayGameInfo();
    }
}
        
        // Function to start a new game, resetting state and showing character creation
        async function startGame() {
    console.log('[startGame] Starting new game...');
    gameState = JSON.parse(JSON.stringify(defaultGameStateTemplate));
    gameOutput.innerHTML = '';
    gameState.gamePhase = 'initial_setup';
    characterCreationInProgress = true;
    await deleteGameState();
    showCharacterCreationModal();
    
    // Сброс полей
    charNameInput.value = '';
    charGenderSelect.value = 'мужской';
    charRaceSelect.value = 'человек'; // НОВОЕ
    
    commandInput.disabled = true;
    submitCommandBtn.disabled = true;
    loadingIndicatorEl.classList.add('hidden');
    commandInput.value = '';
    saveGameState();
    updateSlavaThoughtsDisplay();
    gameOverMessage.classList.add('hidden');
}
        
        // Initializes Firebase and attempts to load the game state from Firestore
        async function initializeFirebase() {
            console.log('[initializeFirebase] Initializing Firebase...');
            try {
                // Display global loading overlay
                document.body.classList.add('loading-overlay');
                globalLoaderEl.classList.remove('hidden');
                gameContainerEl.style.display = 'none'; // Hide game content until loaded
                // Retrieve Firebase config and auth token from the global window object
                const firebaseConfigForGemini = window.__firebase_config;
                const parsedFirebaseConfig = JSON.parse(firebaseConfigForGemini);
                const initialAuthToken = window.__initial_auth_token;
                // Initialize Firebase app, Firestore, and Auth services
                app = initializeApp(parsedFirebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Attempt to sign in with custom token, or log a warning if not available
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    console.warn("Начальный токен аутентификации не найден. Пользователь может не быть автоматически аутентифицирован.");
                }
                // Listen for changes in authentication state
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid; // Set the user ID
     
                        await loadGameState(); // Load game state for the authenticated user
                        isGameReady = true; // Mark game as ready
                        
                 
                        // Enable game inputs and display game content
                        commandInput.disabled = false;
                        submitCommandBtn.disabled = false;
                        gameContainerEl.style.display = 'flex';
        
                        document.body.classList.remove('loading-overlay'); // Hide loading overlay
                        globalLoaderEl.classList.add('hidden');
                        displayGameInfo(); // Update UI with loaded game info
                    } else {
   
                        // Handle unauthenticated state
                        console.error("Firebase Auth State Changed: Пользователь не вошел в систему.");
                        showMessageModal("Ошибка Авторизации", "Не удалось авторизоваться. Сохранение прогресса может быть невозможно. Пожалуйста, сообщите разработчику об этой ошибке.");
                        commandInput.disabled = true;
                        submitCommandBtn.disabled = true;
                        gameContainerEl.style.display = 'flex';
                        document.body.classList.remove('loading-overlay');
                        globalLoaderEl.classList.add('hidden');
                    }
                });
            } catch (error) {
                console.error("Ошибка инициализации приложения Firebase:", error);
                showMessageModal("Критическая Ошибка", "Критическая ошибка инициализации игры. Сохранение прогресса будет невозможно. Подробности ошибки: " + error.message);
                // Still display the game even if Firebase init fails, but with disabled inputs
                commandInput.disabled = true;
                submitCommandBtn.disabled = true;
                gameContainerEl.style.display = 'flex';
                document.body.classList.remove('loading-overlay');
                globalLoaderEl.classList.add('hidden');
            }
        }
        
        // Saves the current game state to Firestore
        async function saveGameState() {
            // Ensure Firestore is initialized and user is authenticated before saving
            if (!userId || !db) {
            
                console.warn("Firestore не инициализирован или пользователь не аутентифицирован. Невозможно сохранить состояние игры.");
                return;
            }
            try {
                // Reference to the user's game state document
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/game_state`, "current");
                // Create a deep copy of gameState to avoid issues with Firebase's internal objects
                const stateToSave = JSON.parse(JSON.stringify(gameState));
                await setDoc(docRef, stateToSave, { merge: false }); // Overwrite existing document
            } catch (error) {
                console.error("Ошибка сохранения состояния игры:", error);
                showMessageModal("Ошибка Сохранения", "Ошибка сохранения игры. Пожалуйста, проверьте подключение или сообщите об ошибке.");
            }
        }
        
        // Loads the game state from Firestore
        async function loadGameState() {
            console.log('[loadGameState] Loading game state...');
            // Ensure Firestore is initialized and user is authenticated before loading
            if (!userId || !db) {
                console.warn("Firestore не инициализирован или пользователь не аутентифицирован. Невозможно загрузить состояние игры.");
                return;
            }
            try {
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/game_state`, "current");
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    // If document exists, load and merge data
                    const loadedData = docSnap.data();
                    gameState = JSON.parse(JSON.stringify(defaultGameStateTemplate)); // Start with clean template
                    gameState = deepMerge(gameState, loadedData); // Deep merge loaded data into current state
                    displayMessage("Прогресс загружен!");
                    console.log('[loadGameState] Game state loaded successfully:', gameState);
                } else {
                    // If no saved game, start a new one
                    console.log('[loadGameState] No saved game found. Starting new game.');
                    startGame();
                }
            } catch (error) {
                console.error("Ошибка загрузки состояния игры:", error);
                showMessageModal("Ошибка Загрузки", "Ошибка загрузки игры. Начинаем новую игру.");
                startGame(); // Start a new game on load error
            }
        }
        
        // Deletes the saved game state from Firestore
        async function deleteGameState() {
            // Ensure userId and db are available
            if (!userId || !db) { return; }
            try {
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/game_state`, "current");
                await deleteDoc(docRef);
                console.log('[deleteGameState] Game state deleted successfully.');
            } catch (error)
            {
                console.error("Ошибка удаления состояния игры:", error);
            }
        }
        
        // Event listener for command submission button click
        submitCommandBtn.addEventListener('click', () => {
            const command = commandInput.value.trim();
            if (command) {
                processCommand(command);
            }
 
        });
        
        // Event listener for Enter key press in the command input field
        commandInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitCommandBtn.click(); // Trigger button click on Enter key
            }
        });
        // Event listener for "New Game" button click, shows confirmation modal
        newGameButton.addEventListener('click', () => {
            newGameModal.classList.remove('hidden');
        });
        // Event listener for confirming new game in the modal
        confirmNewGameBtn.addEventListener('click', () => {
            newGameModal.classList.add('hidden'); // Hide modal
            startGame(); // Start a new game
        });
        // Event listener for canceling new game in the modal
        cancelNewGameBtn.addEventListener('click', () => {
            newGameModal.classList.add('hidden'); // Hide modal
            if (gameState.gamePhase !== 'dead') {
                displayGameInfo(); // Just refresh UI if not dead and cancelling
            }
        });
        
        // REMOVED: Event listener for newCharacterButton is gone.

        // Input event listener for character name input to enable/disable create button
        charNameInput.addEventListener('input', () => {
            // Enable button only if name is entered and a skill is selected
            createCharButton.disabled = charNameInput.value.trim() === '' || (gameState.player.skills && gameState.player.skills.length === 0);
        });
        // Event listener for creating character from the character creation modal
        createCharButton.addEventListener('click', async () => {
    console.log('[createCharButton] Create character button clicked.');
    if (charNameInput.value.trim() === '') {
        showMessageModal('Ошибка', 'Пожалуйста, введите имя вашего персонажа.');
        return;
    }
    if (!gameState.player.skills || gameState.player.skills.length === 0) {
        showMessageModal('Ошибка', 'Пожалуйста, выберите стартовый навык.');
        return;
    }

    const name = charNameInput.value.trim();
    const gender = charGenderSelect.value;
    const race = charRaceSelect.value; // НОВОЕ: Получаем расу

    charCreationModal.classList.add('hidden'); // Hide modal
    loadingIndicatorEl.classList.remove('hidden'); // Show loader

    // Передаем расу третьим аргументом
    await sendInitialGameSetupPromptToLLM(name, gender, race);
});
        // Attach event listeners for new character description modal
        showCharacterDescriptionButton.addEventListener('click', updateCharacterDescriptionDisplay);
        closeCharDescriptionBtn.addEventListener('click', () => {
            characterDescriptionModal.classList.add('hidden');
        });
        // Attach event listeners for property modal
        propertyButton.addEventListener('click', showPropertyModal);
        closePropertyBtn.addEventListener('click', closePropertyModal);
// НОВОЕ: Обработчики для модального окна карты
mapButton.addEventListener('click', () => {
    mapModal.classList.remove('hidden');
    renderInteractiveMap(); // Отрисовываем карту при открытии
});

closeMapBtn.addEventListener('click', () => {
    mapModal.classList.add('hidden');
    // Прячем тултипы, которые могли остаться видимыми
    hideTooltip();
    const mapTooltip = document.getElementById('mapTooltip');
    if (mapTooltip) {
        mapTooltip.classList.add('hidden');
    }
});

        // Initialize Firebase when the window loads
        window.onload = initializeFirebase;
        // Global click listener to hide tooltips when clicking outside
        document.body.addEventListener('click', (event) => {
            // Check if the click target or any of its ancestors is not a tooltip trigger or the tooltip/modal itself
            if (!event.target.closest('.skill-item') && !event.target.closest('.inventory-item') &&
                !event.target.closest('.npc-item') && !event.target.closest('.location-item') &&
              
                !event.target.closest('.lore-item') && !event.target.closest('.equipment-list-item') &&
                !event.target.closest('.status-item') && !event.target.closest('.game-tooltip') &&
                !event.target.closest('.companion-item') &&
                !event.target.closest('.notebook-entry') &&
                !event.target.closest('.modal')) {
                hideTooltip();
         
            }
        });
// ДОБАВИТЬ ЭТИ ОБРАБОТЧИКИ В КОНЕЦ ФАЙЛА
recordsButton.addEventListener('click', showRecordsModal);
closeRecordsBtn.addEventListener('click', closeRecordsModal);

questsButton.addEventListener('click', showQuestsModal);
closeQuestsBtn.addEventListener('click', closeQuestsModal);

charactersButton.addEventListener('click', showCharactersModal);
closeCharactersBtn.addEventListener('click', closeCharactersModal);

locationsButton.addEventListener('click', showLocationsModal);
closeLocationsBtn.addEventListener('click', closeLocationsModal);

// Логика переключения вкладок в окне квестов
questTabButtons.forEach(button => {
    button.addEventListener('click', () => {
        const targetTab = button.dataset.tab;
        questTabButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');

        questTabContents.forEach(content => content.classList.add('hidden'));
        document.getElementById(`${targetTab}QuestsTab`).classList.remove('hidden');
    });
});
    </script>
</body>
</html>
